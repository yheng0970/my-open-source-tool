<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç¬”è®°å¡ç‰‡ - HTMLå®æ—¶é¢„è§ˆå·¥å…·</title>
  
  <!-- html2canvas CDN -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  
  <style>
    /* =================== é‡ç½®æ ·å¼ =================== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      background: #f5f7fa;
    }

    /* =================== å®¹å™¨å¸ƒå±€ =================== */
    .container {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* =================== æ ‡é¢˜æ  =================== */
    .header {
      height: 50px;
      padding: 0 30px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .header h1 {
      font-size: 18px;
      color: #fff;
      font-weight: 500;
      margin: 0;
    }

    /* =================== ä¸»å†…å®¹åŒº =================== */
    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* =================== å·¦ä¾§è¾“å…¥åŒº =================== */
    .input-section {
      flex: 0 1 400px;
      min-width: 280px;
      max-width: 50%;
      display: flex;
      flex-direction: column;
      background: #282c34;
      border-right: 1px solid #e1e4e8;
    }

    .section-title {
      padding: 12px 20px;
      font-size: 13px;
      color: #fff;
      background: #21252b;
      border-bottom: 1px solid #181a1f;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
      z-index: 10; /* é˜²æ­¢è¢«é¢„è§ˆå±‚è¦†ç›–ï¼Œä¿è¯æŒ‰é’®å¯ç‚¹ */
    }

    .title-buttons {
      display: flex;
      gap: 8px;
    }

    .btn {
      padding: 4px 12px;
      font-size: 12px;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-paste {
      background: #4CAF50;
    }

    .btn-paste:hover {
      background: #45a049;
    }

    .btn-clear {
      background: #f44336;
    }

    .btn-clear:hover {
      background: #da190b;
    }

    .btn-export {
      background: #2196F3;
    }

    .btn-export:hover {
      background: #0b7dda;
    }

    .btn-export:disabled {
      background: #ccc;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .ratio-select {
      padding: 4px 8px;
      font-size: 12px;
      color: #333;
      border: 1px solid #e1e4e8;
      border-radius: 4px;
      background: #fff;
    }

    .width-input {
      width: 88px;
      padding: 4px 8px;
      font-size: 12px;
      color: #333;
      border: 1px solid #e1e4e8;
      border-radius: 4px;
      background: #fff;
    }

    #htmlInput {
      flex: 1;
      width: 100%;
      padding: 20px;
      border: none;
      background: #282c34;
      color: #abb2bf;
      font-size: 14px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.6;
      resize: none;
      outline: none;
      tab-size: 2;
    }

    #htmlInput::placeholder {
      color: #5c6370;
    }

    /* =================== å³ä¾§é¢„è§ˆåŒº =================== */
    .preview-section {
      flex: 1 1 auto;
      min-width: 50%;
      display: flex;
      flex-direction: column;
      background: #fff;
    }

    #preview {
      flex: 1;
      padding: 0;
      overflow: auto;
      background: #fff;
      border: none;
      width: 100%;
      height: 100%;
    }

    .preview-viewport {
      flex: 1;
      display: flex;
      min-height: 0;
      position: relative;
      z-index: 1;
    }

    .preview-scaler {
      flex: 1;
      position: relative;
      display: flex;
      z-index: 0;
    }

    .preview-section.ratio-mode {
      overflow: auto;
      background: #fff;
    }

    .preview-section.ratio-mode .preview-viewport {
      flex: 0 0 auto;
      width: 100%;
      height: auto;
      aspect-ratio: var(--ratio);
      position: relative;
      overflow: hidden;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
      margin: 12px;
      background: #fff;
    }

    .preview-section.ratio-mode .preview-scaler {
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      z-index: 0; /* æ°¸è¿œåœ¨æ ‡é¢˜ä¸‹æ–¹ */
    }

    /* =================== åº•éƒ¨çŠ¶æ€æ  =================== */
    .footer {
      height: 30px;
      padding: 0 20px;
      background: #fff;
      border-top: 1px solid #e1e4e8;
      display: flex;
      align-items: center;
      font-size: 12px;
      color: #666;
    }

    /* =================== æ»šåŠ¨æ¡æ ·å¼ =================== */
    #htmlInput::-webkit-scrollbar,
    #preview::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    #htmlInput::-webkit-scrollbar-track {
      background: #21252b;
    }

    #htmlInput::-webkit-scrollbar-thumb {
      background: #4b5263;
      border-radius: 5px;
    }

    #htmlInput::-webkit-scrollbar-thumb:hover {
      background: #5c6370;
    }

    #preview::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    #preview::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 5px;
    }

    #preview::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* =================== å“åº”å¼ =================== */
    @media (max-width: 768px) {
      .main {
        flex-direction: column;
      }
      
      .input-section,
      .preview-section {
        flex: 1;
        min-height: 50%;
      }
    }
    .log-panel {
      height: 160px;
      display: none;
      background: #0f1115;
      color: #9aa0a6;
      border-top: 1px solid #e1e4e8;
      overflow: auto;
    }
    .log-output {
      padding: 8px 12px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-all;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- æ ‡é¢˜æ  -->
    <header class="header">
      <h1>ğŸ¨ HTML å®æ—¶é¢„è§ˆå·¥å…·</h1>
    </header>
    
    <!-- ä¸»å†…å®¹åŒº -->
    <main class="main">
      <!-- å·¦ä¾§ï¼šHTMLä»£ç è¾“å…¥ -->
      <div class="input-section">
        <div class="section-title">
          <span>ğŸ“ HTML ä»£ç </span>
          <div class="title-buttons">
            <button class="btn btn-paste" onclick="handlePaste()">ğŸ“‹ ç²˜è´´</button>
            <button class="btn btn-clear" onclick="handleClear()">ğŸ—‘ï¸ æ¸…ç©º</button>
          </div>
        </div>
        <textarea id="htmlInput" placeholder="åœ¨è¿™é‡Œè¾“å…¥HTMLä»£ç ï¼Œå³ä¾§ä¼šå®æ—¶æ˜¾ç¤ºæ•ˆæœ...

ç¤ºä¾‹ï¼š
<h1>ä½ å¥½ï¼Œä¸–ç•Œï¼</h1>
<p style='color: blue;'>è¿™æ˜¯ä¸€æ®µè“è‰²çš„æ–‡å­—</p>
<button onclick='alert(&quot;ç‚¹å‡»æˆåŠŸï¼&quot;)'>ç‚¹æˆ‘è¯•è¯•</button>"></textarea>
      </div>
      
      <!-- å³ä¾§ï¼šå®æ—¶é¢„è§ˆ -->
      <div class="preview-section">
        <div class="section-title">
          <span>ğŸ‘€ å®æ—¶é¢„è§ˆ</span>
          <div class="title-buttons">
            <select id="ratioSelect" class="ratio-select" title="æ˜¾ç¤ºæ¯”ä¾‹">
              <option value="auto">é»˜è®¤</option>
              <option value="3:4">3:4</option>
              <option value="4:3">4:3</option>
              <option value="1:1">1:1</option>
              <option value="9:16">9:16</option>
              <option value="16:9">16:9</option>
            </select>
            <select id="borderSelect" class="ratio-select" title="è¾¹è·">
              <option value="0">æ— è¾¹è·</option>
              <option value="16">ç•™ç™½16</option>
              <option value="24">ç•™ç™½24</option>
              <option value="32">ç•™ç™½32</option>
            </select>
            <button id="autoExportBtn" class="btn btn-export" onclick="handleAutoExport(event)" disabled>âš¡ ä¸€é”®å¯¼å‡º(100%)</button>
          </div>
        </div>
        <div id="previewViewport" class="preview-viewport">
          <div id="previewScaler" class="preview-scaler">
            <iframe id="preview" sandbox="allow-scripts allow-same-origin allow-forms allow-modals allow-pointer-lock allow-popups allow-presentation allow-top-navigation-by-user-activation"></iframe>
          </div>
        </div>
      </div>
    </main>
    <div id="logPanel" class="log-panel"><pre id="logOutput" class="log-output"></pre></div>
    
    <!-- åº•éƒ¨çŠ¶æ€æ  -->
    <footer class="footer">
      <span id="status">ç­‰å¾…è¾“å…¥...</span>
    </footer>
  </div>

  <script>
    console.log('[App] HTMLé¢„è§ˆå·¥å…·å¯åŠ¨', new Date().toLocaleString());

    // è·å–å…ƒç´ 
    const htmlInput = document.getElementById('htmlInput');
    const preview = document.getElementById('preview');
    const status = document.getElementById('status');
    const autoExportBtn = document.getElementById('autoExportBtn');
    const ratioSelect = document.getElementById('ratioSelect');
    const borderSelect = document.getElementById('borderSelect');
    const previewViewport = document.getElementById('previewViewport');
    const previewScaler = document.getElementById('previewScaler');
    const logPanel = document.getElementById('logPanel');
    const logOutput = document.getElementById('logOutput');
    const logToggleBtn = document.getElementById('logToggleBtn');
    const exportLogBtn = document.getElementById('exportLogBtn');
    let DESIGN_BASE_WIDTH = 1200;
    let RATIO_Y_OFFSET = 0; // æ¯”ä¾‹æ¨¡å¼ä¸‹ï¼Œä¸ºæ¶ˆé™¤é¡¶éƒ¨ç©ºç™½è€Œå‘ä¸Šå¹³ç§»çš„æœªç¼©æ”¾åƒç´ å€¼
    let EXPORT_BLEED = 0;
    let EXPORT_MAX_COVERAGE = false; // å…³é—­æœ€å¤§è¦†ç›–å¯¼å‡ºï¼Œæ¢å¤åŸæœ‰è¡Œä¸º
    let CURRENT_PREVIEW_URL = null; // é¢„è§ˆç”¨ blob: URLï¼Œé¿å… srcdoc æˆªæ–­
    let RAW_MODE = false; // åŸæ ·æ¸²æŸ“å¼€å…³
    const FORCE_EXTRA_TRIM = false;
    const ADV_TRIM_EDGES = true; // å¼€å¯èƒŒæ™¯å»è¾¹è£åˆ‡ï¼ˆä»…æ— è¾¹è·æ¨¡å¼ç”Ÿæ•ˆï¼‰ï¼Œè‡ªåŠ¨ç§»é™¤ç™½è¾¹
    const FORCE_FULLPAGE_CROP = false; // å…³é—­å¼ºåˆ¶å…¨å¹…ï¼Œå¯ç”¨å†…å®¹è‡ªé€‚åº”è£åˆ‡
    const Logger = (() => {
      const key = 'html_preview_logs';
      let list = [];
      const maxEntries = 5000;
      const ts = () => new Date().toISOString();
      const safeStr = (x) => { try { return typeof x === 'string' ? x : JSON.stringify(x); } catch { return String(x); } };
      const write = (level, msg, extra) => {
        const item = { t: ts(), level, msg, extra };
        list.push(item);
        if (list.length > maxEntries) list = list.slice(-Math.floor(maxEntries * 0.8));
        try { localStorage.setItem(key, JSON.stringify(list)); } catch {}
        if (logOutput) {
          logOutput.textContent += `[${item.t}] [${level}] ${msg}${extra !== undefined ? ' ' + safeStr(extra) : ''}\n`;
          if (logPanel && logPanel.style.display !== 'none') logPanel.scrollTop = logPanel.scrollHeight;
        }
      };
      try {
        const saved = localStorage.getItem(key);
        if (saved) {
          list = JSON.parse(saved);
          if (logOutput) logOutput.textContent = list.map(i => `[${i.t}] [${i.level}] ${i.msg}${i.extra ? ' ' + safeStr(i.extra) : ''}`).join('\n') + (list.length ? '\n' : '');
        }
      } catch {}
      return {
        log: (m, e) => write('INFO', m, e),
        warn: (m, e) => write('WARN', m, e),
        error: (m, e) => write('ERROR', m, e),
        section: (m) => write('----', m),
        clear: () => { list = []; try { localStorage.removeItem(key); } catch {}; if (logOutput) logOutput.textContent = ''; },
        all: () => list.slice(),
        export: () => {
          const text = logOutput?.textContent || list.map(i => `[${i.t}] [${i.level}] ${i.msg}${i.extra ? ' ' + safeStr(i.extra) : ''}`).join('\n');
          const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `html-preview-logs-${Date.now()}.txt`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(() => URL.revokeObjectURL(a.href), 200);
        },
        toggle: () => { if (!logPanel) return false; const show = logPanel.style.display === 'none'; logPanel.style.display = show ? 'block' : 'none'; return show; },
        check: () => { const hasError = list.some(i => i.level === 'ERROR'); const warnCount = list.filter(i => i.level === 'WARN').length; return { count: list.length, hasError, warnCount }; }
      };
    })();
    

    // åˆå§‹åŒ–ç¤ºä¾‹ä»£ç 
    const exampleHTML = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    h1 {
      text-align: center;
    }
    .card {
      background: white;
      color: #333;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
  </style>
</head>
<body>
  <h1>ğŸ‰ æ¬¢è¿ä½¿ç”¨ HTML é¢„è§ˆå·¥å…·</h1>
  
  <div class="card">
    <h2>å¿«é€Ÿå¼€å§‹</h2>
    <p>åœ¨å·¦ä¾§ç¼–è¾‘HTMLä»£ç ï¼Œå³ä¾§ä¼šå®æ—¶æ˜¾ç¤ºæ•ˆæœã€‚</p>
    <button onclick="alert('æŒ‰é’®ç‚¹å‡»æˆåŠŸï¼')">ç‚¹å‡»æµ‹è¯•</button>
  </div>
  
  <div class="card">
    <h2>æ”¯æŒçš„åŠŸèƒ½</h2>
    <ul>
      <li>å®Œæ•´çš„HTMLæ ‡ç­¾</li>
      <li>å†…è”CSSæ ·å¼</li>
      <li>JavaScriptäº¤äº’</li>
      <li>å®æ—¶é¢„è§ˆ</li>
    </ul>
  </div>
</body>
</html>`;

    // ç®€å•æ¸…æ´—ï¼šç§»é™¤<script>å’Œå†…è” on* äº‹ä»¶ï¼Œé¿å…è¿è¡Œæ—¶æŠ¥é”™å¯¼è‡´ç™½å±
    function sanitizeHTML(code) {
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(code, 'text/html');
        doc.querySelectorAll('script').forEach(s => s.remove());
        doc.querySelectorAll('*').forEach(el => {
          for (const a of Array.from(el.attributes)) {
            if (/^on/i.test(a.name)) el.removeAttribute(a.name);
          }
        });
        const hasDoctype = /<!DOCTYPE/i.test(code);
        if (hasDoctype) {
          const doctype = doc.doctype ? `<!DOCTYPE ${doc.doctype.name}>\n` : '<!DOCTYPE html>\n';
          return doctype + doc.documentElement.outerHTML;
        }
        return doc.body.innerHTML;
      } catch (e) {
        return code;
      }
    }

    // å¤„ç†HTMLä»£ç ï¼šå¦‚æœä¸æ˜¯å®Œæ•´æ–‡æ¡£ï¼Œè‡ªåŠ¨åŒ…è£¹ï¼ˆé¢„è§ˆä¸åšæ¸…æ´—ï¼Œä¿æŒåŸå§‹æ•ˆæœï¼‰
    function getPreviewHtml(code) {
      if (!code.trim()) return '';
      if (RAW_MODE) {
        // åŸæ ·æ¸²æŸ“ï¼šä»…åœ¨æ£€æµ‹åˆ°æ–‡æ¡£èµ·ç‚¹æ—¶ï¼Œä»æ–‡æ¡£èµ·ç‚¹å¼€å§‹ï¼Œå…¶ä»–ä¸åšä»»ä½•æ”¹å†™
        try {
          const lower = code.toLowerCase();
          let i = lower.indexOf('<!doctype');
          if (i === -1) i = lower.indexOf('<html');
          return i > 0 ? code.slice(i) : code;
        } catch { return code; }
      }

      // é¢„æ¸…æ´—ï¼šè‹¥åŒ…å«å¤šä»½æ–‡æ¡£æˆ–å¸¦æœ‰â€œå®é™…æˆ‘çš„å®Œæ•´ä»£ç ï¼šâ€ä¹‹ç±»çš„æ ‡æ³¨ï¼Œ
      // ä»¥â€œç¬¬ä¸€ä»½ <!DOCTYPE>â€ä¸ºä¸»ï¼›è‹¥åœ¨æ ‡æ³¨åæ‰å‡ºç°ç¬¬ä¸€ä»½ DOCTYPEï¼Œæ‰ä»æ ‡æ³¨åå¼€å§‹ã€‚
      try {
        const original = code;
        const lower = original.toLowerCase();
        const marker = 'å®é™…æˆ‘çš„å®Œæ•´ä»£ç ';
        const firstDoctype = lower.indexOf('<!doctype');
        const markerPos = lower.indexOf(marker);
        let chosen = original;
        const hasStyles = (s) => /<style\b|rel=["']?stylesheet["']?/i.test(s);
        if (markerPos !== -1) {
          const dtAfterMarker = lower.indexOf('<!doctype', markerPos);
          if (dtAfterMarker !== -1) {
            const cand = original.slice(dtAfterMarker);
            if (/<html\b/i.test(cand) && hasStyles(cand)) chosen = cand;
          } else {
            const cand = original.slice(markerPos + marker.length);
            if (/<html\b/i.test(cand) && hasStyles(cand)) chosen = cand;
          }
        } else if (firstDoctype > 0) {
          chosen = original.slice(firstDoctype);
        }
        code = chosen;
      } catch {}

      // ç®€å•åˆ¤ç©ºå·¥å…·
      const looksEmpty = (html) => {
        try {
          const p = new DOMParser();
          const d = p.parseFromString(html, 'text/html');
          const text = (d.body?.innerText || '').replace(/\s+/g, ' ').trim();
          const visuals = d.body ? d.body.querySelectorAll('img,svg,canvas,video,table,div,section,article,main,p,h1,h2,h3,h4,h5,h6').length : 0;
          return text.length < 2 && visuals < 1;
        } catch { return false; }
      };
      // é‡å»ºç­–ç•¥ï¼šä»åŸå§‹æ–‡æœ¬ä¸­æŠ½å–æ ·å¼ä¸ä¸»ä½“å†…å®¹ï¼Œé‡æ–°æ‹¼è£…ä¸ºå®Œæ•´æ–‡æ¡£
      const rebuildFromPieces = (raw) => {
        try {
          const getAll = (re) => Array.from(raw.matchAll(re)).map(m => m[0]).join('\n');
          const styles = getAll(new RegExp('<style[^>]*>[\\s\\S]*?<\\/style>', 'ig'));
          const links = getAll(/<link[^>]+rel=["']?stylesheet["']?[^>]*>/ig);
          let bodyHTML = '';
          const mBody = raw.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
          if (mBody) bodyHTML = (mBody[1] || '').trim();
          if (!bodyHTML) {
            // å»æ‰ <head> å—ä¸åŒ…è£¹æ ‡ç­¾åä½œä¸ºä¸»ä½“
            let tmp = raw.replace(/<head[^>]*>[\s\S]*?<\/head>/ig, '');
            tmp = tmp.replace(/<!DOCTYPE[^>]*>/ig, '').replace(/<\/?html[^>]*>/ig, '');
            tmp = tmp.replace(new RegExp('<title[^>]*>[\\s\\S]*?<\\/title>', 'ig'), '')
                     .replace(/<meta[^>]*>/ig, '')
                     .replace(new RegExp('<script[\\s\\S]*?<\\\\/script>', 'ig'), '');
            bodyHTML = tmp.trim();
          }
          return `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  ${links}\n  ${styles}\n</head>\n<body>\n${bodyHTML}\n</body>\n</html>`;
        } catch { return raw; }
      };

      // å¦‚æœåŒ…å« <html> æˆ– DOCTYPEï¼Œå°è¯•ä¿®å¤æ˜æ˜¾çš„ç»“æ„é”™è¯¯ï¼ˆä¾‹å¦‚æŠŠå‡ºç°åœ¨ <head> çš„å—çº§å…ƒç´ ç§»åˆ° <body>ï¼‰ï¼Œ
      // è‹¥ä¿®å¤åå­—ç¬¦ä¸²å˜åŒ–è¿‡å¤§åˆ™å›é€€åˆ°åŸæ–‡
      if (/<html\b/i.test(code)) {
        // ä¿®å¤æœªé—­åˆçš„ <style>/<script>ï¼Œé¿å…åç»­å†…å®¹è¢«å½“ä½œæ ·å¼/è„šæœ¬åæ‰
        try {
          const count = (s, re) => (s.match(re) || []).length;
          const styleOpen = count(code, /<style\b[^>]*>/ig);
          const styleClose = count(code, new RegExp('<\\/style>', 'ig'));
          if (styleClose < styleOpen) code += '</style>'.repeat(styleOpen - styleClose);
          const scriptOpen = count(code, /<script\b[^>]*>/ig);
          const scriptClose = count(code, new RegExp('<\\\/script>', 'ig'));
          if (scriptClose < scriptOpen) code += '<\\/script>'.repeat(scriptOpen - scriptClose);
        } catch {}
        try {
          const parser = new DOMParser();
          const doc = parser.parseFromString(code, 'text/html');
          const body = doc.body || doc.getElementsByTagName('body')[0];
          const head = doc.head || doc.getElementsByTagName('head')[0];
          if (head && body) {
            const illegalSel = 'div,section,article,main,header,footer,nav,aside,h1,h2,h3,h4,h5,h6,p,ul,ol,li,table,hr,form,iframe,canvas,svg,video,audio';
            const illegals = Array.from(head.querySelectorAll(illegalSel));
            illegals.forEach(n => { try { body.insertBefore(n, body.firstChild); } catch {} });
            // ç§»é™¤ <head> æ—©æœŸå‡ºç°çš„å­¤ç«‹é—­åˆæ ‡ç­¾
            const orphanCloses = Array.from(head.childNodes).filter(n => n.nodeType === 3 && /<\/(div|section|p)>/i.test(n.textContent || ''));
            orphanCloses.forEach(n => head.removeChild(n));
          }
          // è‹¥æºæ–‡æ¡£åœ¨ </html> ä¹‹åè¿˜æœ‰æ ‡ç­¾ï¼Œå°½å¯èƒ½æ‹¼æ¥è¿› body
          try {
            const lowerSrc = code.toLowerCase();
            const htmlEnd = lowerSrc.lastIndexOf('</html>');
            if (htmlEnd > 0 && htmlEnd + 7 < code.length) {
              const tail = code.slice(htmlEnd + 7).trim();
              if (tail && /<\w+[\s>]/.test(tail)) {
                const frag = parser.parseFromString(`<!DOCTYPE html><html><body>${tail}</body></html>`, 'text/html');
                Array.from(frag.body.childNodes).forEach(n => body.appendChild(doc.importNode(n, true)));
              }
            }
          } catch {}
          const doctype = doc.doctype ? `<!DOCTYPE ${doc.doctype.name}>` : '<!DOCTYPE html>';
          const normalized = doctype + '\n' + doc.documentElement.outerHTML;
          if (normalized.length < code.length * 0.7) return code; // ä¿æŠ¤ï¼šå˜çŸ­å¤ªå¤šæ—¶å›é€€
          // è‹¥è§„èŒƒåŒ–åå‡ ä¹æ²¡æœ‰å¯è§å†…å®¹ï¼Œä½¿ç”¨é‡å»ºç­–ç•¥
          if (looksEmpty(normalized)) return rebuildFromPieces(code);
          return normalized;
        } catch { return code; }
      }

      // ç‰‡æ®µæ¨¡å¼ï¼šç§»é™¤ä»»ä½•æ•£è½åœ¨ç‰‡æ®µé‡Œçš„ DOCTYPEï¼Œé¿å…è¢«æ’å…¥åˆ° <body> ä¸­å¯¼è‡´æ¸²æŸ“å¼‚å¸¸
      let fragment = code.replace(/<!DOCTYPE[^>]*>/ig, '').trim();

      // å¦‚æœç‰‡æ®µé‡ŒåŒ…å« <head> æˆ– <body>ï¼Œå°½é‡æŠ½å–å‡ºæ¥å†åŒ…è£…
      let extractedHead = '';
      const mHead = fragment.match(/<head[^>]*>([\s\S]*?)<\/head>/i);
      if (mHead) {
        extractedHead = mHead[1] || '';
        fragment = fragment.replace(mHead[0], '').trim();
      }

      const mBody = fragment.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
      if (mBody) {
        fragment = (mBody[1] || '').trim();
      }

      let out = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é¢„è§ˆ</title>
  ${extractedHead}
</head>
<body>
${fragment}
</body>
 </html>`;
      if (looksEmpty(out)) out = rebuildFromPieces(code);
      return out;
    }

    function applyDisplayRatio(val) {
      const section = preview.closest('.preview-section');
      if (!section) return;
      if (!val || val === 'auto') {
        section.classList.remove('ratio-mode');
        section.style.removeProperty('--ratio');
        RATIO_Y_OFFSET = 0;
      } else {
        section.classList.add('ratio-mode');
        section.style.setProperty('--ratio', String(val).replace(':', ' / '));
        RATIO_Y_OFFSET = 0;
      }
      requestAnimationFrame(updateRatioScale);
    }

    function parseRatio(v) {
      const m = String(v || '').match(/^(\d+)\s*:\s*(\d+)$/);
      if (!m) return null;
      return [parseFloat(m[1]), parseFloat(m[2])];
    }

    function updateRatioScale() {
      if (!previewViewport || !previewScaler) return;
      const val = ratioSelect ? ratioSelect.value : 'auto';
      const section = preview.closest('.preview-section');
      if (!section) return;
      if (!val || val === 'auto') {
        previewScaler.style.transform = '';
        previewScaler.style.width = '';
        previewScaler.style.height = '';
        previewScaler.style.left = '';
        previewScaler.style.top = '';
        preview.style.width = '';
        preview.style.height = '';
        return;
      }
      const r = parseRatio(val);
      if (!r) return;
      const [rw, rh] = r;
      const designW = Math.max(800, DESIGN_BASE_WIDTH);
      const designH = Math.max(1, Math.round(designW * rh / rw));
      const rect = previewViewport.getBoundingClientRect();
      const vw = rect.width || 1;
      const vh = rect.height || 1;
      const s = Math.max(0.1, Math.min(vw / designW, vh / designH));
      previewScaler.style.width = designW + 'px';
      previewScaler.style.height = designH + 'px';
      preview.style.width = '100%';
      preview.style.height = '100%';
      // å±…ä¸­æ”¾ç½®ç¼©æ”¾åçš„å†…å®¹ï¼ˆæ°´å¹³å±…ä¸­ï¼Œé¡¶éƒ¨å¯¹é½ï¼‰
      const scaledW = designW * s;
      const offsetX = Math.max(0, (vw - scaledW) / 2);
      const offsetY = 0;
      previewScaler.style.left = offsetX + 'px';
      // ä½¿ç”¨ç»å¯¹å®šä½çš„ topï¼ˆå±å¹•åƒç´ ï¼‰æ¥â€œè£åˆ‡â€é¡¶éƒ¨ç©ºç™½
      previewScaler.style.top = (-RATIO_Y_OFFSET) + 'px';
      previewScaler.style.transform = 'scale(' + s + ')';
    }

    // åœ¨æ¯”ä¾‹æ¨¡å¼ä¸‹ï¼Œè‡ªåŠ¨æ£€æµ‹å¹¶ä¿®æ­£ iframe å†…é¡¶éƒ¨å¤§ç©ºç™½ï¼ˆåŒ…æ‹¬å†…éƒ¨æ»šåŠ¨å®¹å™¨çš„æƒ…å†µï¼‰
    function getScrollableContainer(el, doc) {
      const dv = doc.defaultView || doc.parentWindow;
      const isScrollable = (node) => {
        if (!node) return false;
        const st = dv.getComputedStyle(node);
        const oy = st.overflowY, ox = st.overflowX;
        const yScroll = (oy === 'auto' || oy === 'scroll') && (node.scrollHeight - node.clientHeight > 10);
        const xScroll = (ox === 'auto' || ox === 'scroll') && (node.scrollWidth - node.clientWidth > 10);
        return yScroll || xScroll;
      };
      let cur = el;
      while (cur && cur !== doc.body && cur !== doc.documentElement) {
        if (isScrollable(cur)) return cur;
        cur = cur.parentElement;
      }
      return doc.scrollingElement || doc.documentElement || doc.body;
    }
    function getAbsTopByOffset(el, doc) {
      let y = 0, cur = el;
      while (cur && cur !== doc.body) { y += cur.offsetTop || 0; cur = cur.offsetParent; }
      return Math.max(0, Math.round(y));
    }
    function autoFixTopBlank() {
      try {
        if (!ratioSelect || ratioSelect.value === 'auto') return; // é»˜è®¤æ¨¡å¼ä¸æ”¹åŠ¨
        const doc = preview.contentDocument;
        const win = preview.contentWindow;
        if (!doc || !win) return;

        const dv = doc.defaultView || win;
        // ä¼˜å…ˆå¯»æ‰¾æ ‡é¢˜/ä¸»æ ‡é¢˜ç±»å…ƒç´ 
        const prefer = Array.from(doc.body.querySelectorAll(
          'h1, h2, [role="heading"], .title, .page-title, .page_header, .page-header, .heading, .hero-title, .hero__title, [data-title]'
        ));
        let target = null;
        for (const el of prefer) {
          const cs = dv.getComputedStyle(el);
          if (cs.display === 'none' || cs.visibility === 'hidden' || cs.position === 'fixed') continue;
          const rect = el.getBoundingClientRect();
          if (rect.height < 20) continue;
          const txt = (el.textContent || '').trim();
          if (txt.length < 2) continue;
          if (rect.top >= 8) { target = el; break; }
        }
        // è‹¥æœªæ‰¾åˆ°æ ‡é¢˜ï¼Œåˆ™é€€å›åˆ°é€šç”¨å€™é€‰
        if (!target) {
          const candidates = Array.from(doc.body.querySelectorAll(
            'main, section, article, [role="main"], [role="banner"], .content, .container, .hero, .header, p, div'
          ));
          for (const el of candidates) {
            const cs = dv.getComputedStyle(el);
            if (cs.display === 'none' || cs.visibility === 'hidden' || cs.position === 'fixed') continue;
            const rect = el.getBoundingClientRect();
            if (rect.height < 20) continue;
            const txt = (el.textContent || '').trim();
            if (txt.length < 2 && !/^(MAIN|SECTION|ARTICLE)$/i.test(el.tagName)) continue;
            if (rect.top >= 8) { target = el; break; }
          }
          if (!target) return;
        }

        // æ”¶é›†å¯æ»šåŠ¨å®¹å™¨ï¼ˆå« documentElement/body ä¸å†…éƒ¨æ»šåŠ¨å®¹å™¨ï¼‰
        const containers = [doc.documentElement, doc.body];
        const all = Array.from(doc.querySelectorAll('*'));
        for (const el of all) {
          // ä»…è€ƒè™‘åŒ…å«ç›®æ ‡çš„ç¥–å…ˆï¼ˆå‡å°‘è®¡ç®—ï¼‰
          if (!el.contains(target)) continue;
          const cs = dv.getComputedStyle(el);
          const oy = cs.overflowY;
          const ox = cs.overflowX;
          if ((oy === 'auto' || oy === 'scroll' || ox === 'auto' || ox === 'scroll') && (el.scrollHeight - el.clientHeight > 10)) {
            containers.push(el);
          }
        }

        // å®šä½æ»šåŠ¨å®¹å™¨å¹¶ä¼˜å…ˆä½¿ç”¨â€œå†…éƒ¨æ»šåŠ¨â€å¯¹é½
        const container = getScrollableContainer(target, doc);
        let isWindow = false;
        try {
          isWindow = (container === doc.documentElement || container === doc.body || container === (doc.scrollingElement || null));
          const containerTopAbs = isWindow ? 0 : getAbsTopByOffset(container, doc);
          const targetTopAbs = getAbsTopByOffset(target, doc);
          const desiredScrollTop = Math.max(0, Math.round(targetTopAbs - containerTopAbs - 12));
          const maxScroll = isWindow
            ? Math.max(0, (doc.documentElement.scrollHeight || doc.body.scrollHeight || 0) - (win.innerHeight || doc.documentElement.clientHeight || 0))
            : Math.max(0, container.scrollHeight - container.clientHeight);
          if (maxScroll > 0) {
            if (isWindow) { win.scrollTo(0, Math.min(desiredScrollTop, maxScroll)); }
            else { container.scrollTop = Math.min(desiredScrollTop, maxScroll); }
          }
        } catch {}

        // åœ¨ä¸‹ä¸€å¸§æµ‹é‡å‰©ä½™é¡¶éƒ¨è·ç¦»ï¼Œè‹¥ä»æœ‰ç©ºç™½åˆ™è£åˆ‡è¡¥é½
        try {
          requestAnimationFrame(() => {
            const isWin = (container === doc.documentElement || container === doc.body || container === (doc.scrollingElement || null));
            const rectTop = target.getBoundingClientRect().top;
            const containerTop = isWin ? 0 : container.getBoundingClientRect().top;
            const r = parseRatio(ratioSelect.value);
            let s = 1;
            if (r) {
              const [rw, rh] = r;
              const designW = Math.max(800, DESIGN_BASE_WIDTH);
              const designH = Math.max(1, Math.round(designW * rh / rw));
              const rectVp = previewViewport.getBoundingClientRect();
              const vw = rectVp.width || 1, vh = rectVp.height || 1;
              s = Math.max(0.1, Math.min(vw / designW, vh / designH));
            }
            const residualPx = Math.max(0, Math.round((rectTop - containerTop - 12) * s));
            RATIO_Y_OFFSET = residualPx > 2 ? residualPx : 0;
            updateRatioScale();
          });
        } catch {}
      } catch {}
    }

    // å®æ—¶æ›´æ–°é¢„è§ˆ
    function updatePreview() {
      console.log('[Preview] æ›´æ–°é¢„è§ˆ');
      
      const htmlCode = htmlInput.value;
      const previewHtml = getPreviewHtml(htmlCode);
      
      const isFileEnv = (() => { try { return location.protocol === 'file:'; } catch { return false; } })();
      if (isFileEnv) {
        // file:// ç¯å¢ƒä¼˜å…ˆä½¿ç”¨ document.writeï¼Œå…¼å®¹æ€§æœ€å¥½
        try {
          const doc = preview.contentDocument || preview.contentWindow?.document;
          if (doc) { doc.open(); doc.write(previewHtml); doc.close(); }
          else { preview.setAttribute('srcdoc', previewHtml); }
        } catch { preview.setAttribute('srcdoc', previewHtml); }
      } else {
        // http(s) ç¯å¢ƒï¼šé¦–é€‰ blob URLï¼Œé¿å… srcdoc é•¿åº¦é™åˆ¶
        try {
          const blob = new Blob([previewHtml], { type: 'text/html' });
          const url = URL.createObjectURL(blob);
          preview.removeAttribute('srcdoc');
          preview.src = url;
          preview.addEventListener('load', () => {
            try { if (CURRENT_PREVIEW_URL) URL.revokeObjectURL(CURRENT_PREVIEW_URL); } catch {}
            CURRENT_PREVIEW_URL = url;
          }, { once: true });
        } catch {
          try {
            const doc = preview.contentDocument || preview.contentWindow?.document;
            if (doc) { doc.open(); doc.write(previewHtml); doc.close(); }
            else { preview.setAttribute('srcdoc', previewHtml); }
          } catch { preview.setAttribute('srcdoc', previewHtml); }
        }
      }
      
      // æ›´æ–°çŠ¶æ€
      const charCount = htmlCode.length;
      const lineCount = htmlCode.split('\n').length;
      const sum = Logger.check();
      status.textContent = `å·²è¾“å…¥ ${charCount} å­—ç¬¦ | ${lineCount} è¡Œ | æ—¥å¿— ${sum.count}`;
      
      // æ›´æ–°å¯¼å‡ºæŒ‰é’®çŠ¶æ€
      autoExportBtn.disabled = !htmlCode.trim();
      
      console.log('[Preview] æ›´æ–°å®Œæˆ', { å­—ç¬¦æ•°: charCount, è¡Œæ•°: lineCount });
      Logger.log('é¢„è§ˆæ›´æ–°', { chars: charCount, lines: lineCount });
      requestAnimationFrame(updateRatioScale);
    }

    // ä¸€é”®ç²˜è´´
    async function handlePaste() {
      try {
        const text = await navigator.clipboard.readText();
        if (text && text.trim()) {
          htmlInput.value = text;
          updatePreview();
          status.textContent = 'å·²ä»å‰ªè´´æ¿ç²˜è´´';
          return;
        }
        status.textContent = 'å‰ªè´´æ¿ä¸ºç©ºï¼Œè¯·åœ¨å·¦ä¾§è¾“å…¥æ¡†æŒ‰ Ctrl+V ç²˜è´´';
        htmlInput.focus();
      } catch (err) {
        const manual = window.prompt('æ— æ³•ç›´æ¥è¯»å–å‰ªè´´æ¿ï¼Œè¯·åœ¨æ­¤ç²˜è´´(Ctrl+V)åç‚¹ç¡®å®šï¼š');
        if (manual !== null) {
          htmlInput.value = manual;
          updatePreview();
          status.textContent = 'å·²é€šè¿‡æ‰‹åŠ¨ç²˜è´´å¯¼å…¥';
        } else {
          status.textContent = 'æ— æ³•ä¸€é”®è¯»å–å‰ªè´´æ¿ï¼Œè¯·åœ¨å·¦ä¾§è¾“å…¥æ¡†æŒ‰ Ctrl+V ç²˜è´´';
          htmlInput.focus();
        }
      }
    }

    // åŸæ ·æ¸²æŸ“å¼€å…³ï¼ˆæŒ‰é’®æ˜¾ç¤ºâ€œåŸæ ·å¼€/å…³â€ï¼‰
    function toggleRawMode() {
      try {
        RAW_MODE = !RAW_MODE;
        const btn = document.getElementById('rawModeBtn');
        if (btn) btn.textContent = RAW_MODE ? 'åŸæ ·å¼€' : 'åŸæ ·å…³';
        updatePreview();
      } catch (e) {
        console.warn('toggleRawMode failed', e);
      }
    }

    // ä¸€é”®æ¸…ç©º
    function handleClear() {
      htmlInput.value = '';
      updatePreview();
      console.log('ğŸ—‘ï¸ å·²æ¸…ç©º');
      Logger.log('æ¸…ç©ºå†…å®¹');
    }

    // å¯¼å‡ºPNG
    async function handleExportPng() {
      if (!htmlInput.value.trim()) {
        alert('è¯·å…ˆè¾“å…¥HTMLä»£ç ');
        return;
      }

      exportBtn.textContent = 'â³ å¯¼å‡ºä¸­...';
      exportBtn.disabled = true;

      try {
        console.log('ğŸ“ å¼€å§‹å¯¼å‡ºPNG...');

        // è·å–iframe
        const iframeDoc = preview.contentDocument || preview.contentWindow.document;
        if (!iframeDoc || !iframeDoc.body) {
          throw new Error('é¢„è§ˆå†…å®¹æœªå°±ç»ª');
        }

        // ç­‰å¾…æ¸²æŸ“å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 1000));

        // è·å–å®é™…å°ºå¯¸
        const bodyWidth = Math.max(
          iframeDoc.body.scrollWidth,
          iframeDoc.body.offsetWidth,
          iframeDoc.documentElement.scrollWidth,
          iframeDoc.documentElement.offsetWidth,
          1200
        );
        
        const bodyHeight = Math.max(
          iframeDoc.body.scrollHeight,
          iframeDoc.body.offsetHeight,
          iframeDoc.documentElement.scrollHeight,
          iframeDoc.documentElement.offsetHeight,
          800
        );

        console.log('ğŸ“ å†…å®¹å°ºå¯¸:', { width: bodyWidth, height: bodyHeight });

        // ä¼˜å…ˆä½¿ç”¨ rasterizeHTML æä¾›çš„é«˜ä¿çœŸæ¸²æŸ“ï¼ˆæ›´æ¥è¿‘æµè§ˆå™¨å®é™…æ•ˆæœï¼‰
        let canvas
        try {
          const scale = 2
          canvas = document.createElement('canvas')
          canvas.width = Math.max(1, Math.floor(bodyWidth * scale))
          canvas.height = Math.max(1, Math.floor(bodyHeight * scale))
          const ctx = canvas.getContext('2d', { alpha: false })
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.scale(scale, scale)

          // rasterizeHTML æ¸²æŸ“ iframe çš„ Document åˆ°æˆ‘ä»¬åˆ›å»ºçš„ canvas ä¸Š
          await rasterizeHTML.drawDocument(iframeDoc, canvas, {
            width: bodyWidth,
            height: bodyHeight,
            zoom: 1
          })
        } catch (e) {
          console.warn('rasterizeHTML å¤±è´¥ï¼Œå›é€€åˆ° html2canvas:', e?.message)
          // å›é€€ï¼šhtml2canvasï¼ˆå°½é‡ä¿æŒç®€å•ï¼Œé¿å…å¤šä½™å¤„ç†ï¼‰
          canvas = await html2canvas(iframeDoc.body, {
            scale: 2,
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#ffffff',
            logging: false,
            width: bodyWidth,
            height: bodyHeight,
            windowWidth: bodyWidth,
            windowHeight: bodyHeight
          })
        }

        console.log('ğŸ“Š Canvasç”Ÿæˆ:', { width: canvas.width, height: canvas.height });

        if (canvas.width === 0 || canvas.height === 0) {
          throw new Error('ç”Ÿæˆçš„å›¾ç‰‡å°ºå¯¸ä¸º0');
        }

        // ä¸‹è½½PNG
        canvas.toBlob((blob) => {
          if (!blob) {
            throw new Error('å›¾ç‰‡ç”Ÿæˆå¤±è´¥');
          }
          
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `html-preview-${Date.now()}.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          
          setTimeout(() => URL.revokeObjectURL(url), 100);
          
          console.log('âœ… PNGå¯¼å‡ºæˆåŠŸ');
        Logger.log('PNGå¯¼å‡ºæˆåŠŸ');
          
          // æç¤ºç”¨æˆ·
          alert('PNGå¯¼å‡ºæˆåŠŸï¼\n\nğŸ’¡ æç¤ºï¼šå¦‚æœå¯¼å‡ºçš„å›¾ç‰‡é¢œè‰²ä¸ç†æƒ³ï¼Œ\nå¯ä»¥ä½¿ç”¨æµè§ˆå™¨æˆªå›¾åŠŸèƒ½ï¼š\n- Windows: Win + Shift + S\n- Mac: Cmd + Shift + 4\n- Chrome: å³é”® â†’ æ£€æŸ¥ â†’ æˆªå›¾');
        }, 'image/png', 1.0);

      } catch (err) {
        console.error('âŒ å¯¼å‡ºå¤±è´¥:', err);
        Logger.error('å¯¼å‡ºå¤±è´¥', { message: err?.message });
        alert(`å¯¼å‡ºå¤±è´¥ï¼š${err.message}\n\nå¯èƒ½çš„åŸå› ï¼š\n1. å†…å®¹åŒ…å«è·¨åŸŸèµ„æº\n2. æµè§ˆå™¨ä¸æ”¯æŒhtml2canvas\n3. HTMLä»£ç æœ‰é”™è¯¯`);
      } finally {
        exportBtn.textContent = 'ğŸ“¥ å¯¼å‡ºPNG';
        exportBtn.disabled = !htmlInput.value.trim();
      }
    }

    async function waitForStableLayout(doc, timeout = 2500, minFrames = 3) {
      const deadline = Date.now() + timeout;
      let prev = '';
      let stable = 0;
      return await new Promise((resolve) => {
        const step = () => {
          try {
            const b = doc.body, d = doc.documentElement;
            const w = Math.max(b.scrollWidth, d.scrollWidth, b.offsetWidth, d.offsetWidth, 1);
            const h = Math.max(b.scrollHeight, d.scrollHeight, b.offsetHeight, d.offsetHeight, 1);
            const sig = `${w}x${h}`;
            if (sig === prev) stable++; else stable = 0;
            prev = sig;
            if (stable >= minFrames || Date.now() > deadline) { resolve(); return; }
          } catch { resolve(); return; }
          requestAnimationFrame(step);
        };
        step();
      });
    }

    // ä¸€é”®å¯¼å‡ºï¼ˆé«˜ä¿çœŸï¼Œç¦ç”¨å±å¹•æ•è·ï¼Œä»…æ¸²æŸ“é¢„è§ˆHTMLï¼‰
    async function handleAutoExport(evt) {
      if (!htmlInput.value.trim()) return;

      autoExportBtn.textContent = 'â³ å¯¼å‡ºä¸­...';
      autoExportBtn.disabled = true;
      Logger.section('ä¸€é”®å¯¼å‡ºå¼€å§‹');

      // å°å·¥å…·ï¼šç­‰å¾…èµ„æº
      const waitImages = async (doc) => {
        const imgs = Array.from(doc.images || []);
        await Promise.all(imgs.map(img => img.complete && img.naturalWidth ? Promise.resolve() : new Promise(res => {
          img.addEventListener('load', res, { once: true });
          img.addEventListener('error', res, { once: true });
        })));
      };

      try {
        const iframeDoc = preview.contentDocument || preview.contentWindow.document;
        if (!iframeDoc || !iframeDoc.body) throw new Error('é¢„è§ˆå†…å®¹æœªå°±ç»ª');

        // ç­‰å¾…ä¸€å¸§ + å­—ä½“/å›¾ç‰‡å°±ç»ª
        await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        try { await Promise.race([iframeDoc.fonts?.ready ?? Promise.resolve(), new Promise(r=>setTimeout(r,800))]); } catch {}
        await waitImages(iframeDoc);
        await waitForStableLayout(iframeDoc, 2500, 3);
        Logger.log('èµ„æºä¸å¸ƒå±€å°±ç»ª');
        const computeContentBounds = (doc) => {
          const dv = doc.defaultView || window;
          const se = doc.scrollingElement || doc.documentElement || doc.body;
          const sx = (se && (se.scrollLeft || 0)) || (dv && dv.pageXOffset) || 0;
          const sy = (se && (se.scrollTop || 0)) || (dv && dv.pageYOffset) || 0;
          const docW = Math.max(doc.documentElement.scrollWidth || 0, doc.body.scrollWidth || 0);
          const docH = Math.max(doc.documentElement.scrollHeight || 0, doc.body.scrollHeight || 0);
          // æ‰£é™¤ UA é»˜è®¤çš„ body å¤–è¾¹è·å¯¹ rect çš„å½±å“
          const bodyRect = (doc.body && doc.body.getBoundingClientRect) ? doc.body.getBoundingClientRect() : { left: 0, top: 0 };
          let minL = Infinity, minT = Infinity, maxR = -Infinity, maxB = -Infinity;
          const pxNums = (s) => (String(s||'').match(/-?\d*\.?\d+px/g)||[]).map(v=>parseFloat(v));
          const addShadowExt = (base, cs) => {
            try {
              let eL=0,eT=0,eR=0,eB=0;
              const add = (h=0,v=0,blur=0,spread=0) => {
                const ah=Math.abs(h), av=Math.abs(v); const r=Math.max(0, blur)+Math.max(0, spread);
                eL = Math.max(eL, Math.max(0, -h) + r);
                eR = Math.max(eR, Math.max(0,  h) + r);
                eT = Math.max(eT, Math.max(0, -v) + r);
                eB = Math.max(eB, Math.max(0,  v) + r);
              };
              const bs = cs.boxShadow;
              if (bs && bs !== 'none') {
                const m = bs.match(/(?:inset\s*)?(-?\d*\.?\d+px)\s+(-?\d*\.?\d+px)(?:\s+(-?\d*\.?\d+px))?(?:\s+(-?\d*\.?\d+px))?/gi) || [];
                for (const seg of m) {
                  const p = pxNums(seg);
                  if (p.length>=2) add(p[0], p[1], p[2]||0, p[3]||0);
                }
              }
              const ts = cs.textShadow;
              if (ts && ts !== 'none') {
                const m = ts.match(/(-?\d*\.?\d+px)\s+(-?\d*\.?\d+px)(?:\s+(-?\d*\.?\d+px))?/gi) || [];
                for (const seg of m) {
                  const p = pxNums(seg);
                  if (p.length>=2) add(p[0], p[1], p[2]||0, 0);
                }
              }
              const fil = cs.filter;
              if (fil && /drop-shadow\(/i.test(fil)) {
                const ms = fil.match(/drop-shadow\(([^)]+)\)/gi) || [];
                for (const seg of ms) {
                  const p = pxNums(seg);
                  if (p.length>=2) add(p[0], p[1], p[2]||0, p[3]||0);
                }
              }
              if (fil && /blur\(/i.test(fil)) {
                const b = pxNums(fil.match(/blur\(([^)]+)\)/i)?.[0]||'')[0]||0;
                if (b>0) add(0,0,b,0);
              }
              const ow = (parseFloat(cs.outlineWidth)||0) + Math.max(0, parseFloat(cs.outlineOffset)||0);
              if (ow>0) { eL=Math.max(eL,ow); eR=Math.max(eR,ow); eT=Math.max(eT,ow); eB=Math.max(eB,ow); }
              return {l:eL,t:eT,r:eR,b:eB};
            } catch { return {l:0,t:0,r:0,b:0}; }
          };
          const nodes = Array.from(doc.body.querySelectorAll('*'));
          for (const el of nodes) {
            const cs = dv.getComputedStyle(el);
            if (cs.display === 'none' || cs.visibility === 'hidden') continue;
            const rect = el.getBoundingClientRect();
            if (!rect || rect.width < 1 || rect.height < 1) continue;
            let left = rect.left - (bodyRect.left || 0);
            let top = rect.top - (bodyRect.top || 0);
            let right = rect.right - (bodyRect.left || 0);
            let bottom = rect.bottom - (bodyRect.top || 0);
            const eSelf = addShadowExt({left,top,right,bottom}, cs);
            const csB = dv.getComputedStyle(el, '::before');
            const csA = dv.getComputedStyle(el, '::after');
            const eB = csB ? addShadowExt({left,top,right,bottom}, csB) : {l:0,t:0,r:0,b:0};
            const eA = csA ? addShadowExt({left,top,right,bottom}, csA) : {l:0,t:0,r:0,b:0};
            const eL = Math.max(eSelf.l, eB.l, eA.l), eT = Math.max(eSelf.t, eB.t, eA.t), eR = Math.max(eSelf.r, eB.r, eA.r), eBtm = Math.max(eSelf.b, eB.b, eA.b);
            left -= eL; top -= eT; right += eR; bottom += eBtm;
            minL = Math.min(minL, left);
            minT = Math.min(minT, top);
            maxR = Math.max(maxR, right);
            maxB = Math.max(maxB, bottom);
          }
          const full = { x: 0, y: 0, w: Math.max(1, Math.round(docW)), h: Math.max(1, Math.round(docH)) };
          if (!isFinite(minL) || !isFinite(minT) || !isFinite(maxR) || !isFinite(maxB)) {
            Logger.warn('boundsä¸ºç©ºï¼Œé€€å›å…¨å¹…');
            return full;
          }
          // ç´§è´´è£åˆ‡ï¼ˆä¸å†é¢å¤–æ‰©å±•ï¼Œé¿å…æŠŠé¡µé¢è¾¹è·å¸¦å…¥ï¼‰
          const FUDGE = 0;
          let x = Math.max(0, Math.floor(minL + sx - FUDGE));
          let y = Math.max(0, Math.floor(minT + sy - FUDGE));
          let w = Math.min(docW - x, Math.max(1, Math.ceil((maxR - minL) + FUDGE * 2)));
          let h = Math.min(docH - y, Math.max(1, Math.ceil((maxB - minT) + FUDGE * 2)));

          // å®‰å…¨å›é€€ï¼šè‹¥è£åˆ‡å¯¼è‡´é¢ç§¯æˆ–å®½/é«˜è¿œå°äºæ•´é¡µï¼Œåˆ¤å®šä¸º"å±é™©è£å‰ª"ï¼Œç›´æ¥å›é€€å…¨å¹…
          // æ ¹æ®å†…å®¹å°ºå¯¸åŠ¨æ€è®¡ç®—å®¹å·®ï¼ˆå°å›¾ç”¨å°å®¹å·®ï¼Œå¤§å›¾ç”¨å¤§å®¹å·®ï¼‰
          const SAFE_TRIM_TOL = Math.max(6, Math.min(250, Math.ceil(Math.min(docW, docH) * 0.05))); // 5%çš„åŠ¨æ€å®¹å·®ï¼ˆå…è®¸æ›´å®½è¾¹ç¼˜ä¿®å‰ªï¼‰
          const leftGap = Math.max(0, x);
          const topGap = Math.max(0, y);
          const rightGap = Math.max(0, Math.round(docW - (x + w)));
          const bottomGap = Math.max(0, Math.round(docH - (y + h)));
          const areaRatio = (w * h) / Math.max(1, docW * docH);
          const safeEdge = leftGap <= SAFE_TRIM_TOL && rightGap <= SAFE_TRIM_TOL && topGap <= SAFE_TRIM_TOL && bottomGap <= SAFE_TRIM_TOL;
          const safeArea = areaRatio >= 0.85; // é¢ç§¯è‡³å°‘ä¿ç•™85%
          if (!(safeEdge && safeArea)) {
            // å›é€€æ–¹æ¡ˆï¼šæ ¹æ® body çš„ CSS margin å»é™¤å››è¾¹é»˜è®¤ç•™ç™½ï¼ˆå¦‚ UA é»˜è®¤ 8pxï¼‰
            try {
              const csBody = dv.getComputedStyle(doc.body);
              const mL = parseFloat(csBody.marginLeft) || 0;
              const mT = parseFloat(csBody.marginTop) || 0;
              const mR = parseFloat(csBody.marginRight) || 0;
              const mB = parseFloat(csBody.marginBottom) || 0;
              const xAlt = Math.max(0, Math.round(mL));
              const yAlt = Math.max(0, Math.round(mT));
              const wAlt = Math.max(1, Math.round(docW - mL - mR));
              const hAlt = Math.max(1, Math.round(docH - mT - mB));
              if (wAlt > 1 && hAlt > 1 && wAlt <= docW && hAlt <= docH) {
                Logger.warn('ä½¿ç”¨ body è¾¹è·å›é€€è£åˆ‡', { mL, mT, mR, mB });
                return { x: xAlt, y: yAlt, w: wAlt, h: hAlt };
              }
            } catch {}
            Logger.warn('è£åˆ‡è¿‡å¤šï¼Œé€€å›å…¨å¹…', { leftGap, rightGap, topGap, bottomGap, areaRatio });
            return full;
          }
          Logger.log('ä½¿ç”¨ç´§è´´è£åˆ‡', { x, y, w, h });
          return { x, y, w, h };
        };
        
        // è®¡ç®—å®Œæ•´å°ºå¯¸ï¼ˆæå‰è®¡ç®—ï¼Œä¾›åç»­ä½¿ç”¨ï¼‰
        const b = iframeDoc.body, d = iframeDoc.documentElement;
        const width = Math.max(b.scrollWidth, b.offsetWidth, d.scrollWidth, d.offsetWidth, 100);
        const height = Math.max(b.scrollHeight, b.offsetHeight, d.scrollHeight, d.offsetHeight, 100);
        
        // æ ¹æ®å®é™…å†…å®¹å°ºå¯¸åŠ¨æ€è®¡ç®—å®¹å·®å€¼å’Œé™åˆ¶
        const contentArea = width * height;
        const contentSize = Math.max(width, height);
        const sizeCategory = contentSize < 800 ? 'small' : contentSize < 2000 ? 'medium' : contentSize < 4000 ? 'large' : 'xlarge';
        Logger.log('å†…å®¹å°ºå¯¸åˆ†æ', { width, height, area: contentArea, size: contentSize, category: sizeCategory });
        
        // æ— è¾¹æ¡†å¯¼å‡ºï¼šè®¡ç®—å†…å®¹è¾¹ç•Œï¼ˆéšåæ ¹æ®ç­–ç•¥å†³å®šæ˜¯å¦ä½¿ç”¨ï¼‰
        let contentBounds = computeContentBounds(iframeDoc);
        if (FORCE_FULLPAGE_CROP) {
          contentBounds = { x: 0, y: 0, w: width, h: height };
          Logger.warn('å¼ºåˆ¶å…¨å¹…è£åˆ‡å·²å¯ç”¨ï¼Œå¿½ç•¥å†…å®¹è¾¹ç•Œ');
        } else {
          Logger.log('å†…å®¹è¾¹ç•Œ', contentBounds);
          // è‹¥å¼€å¯æœ€å¤§è¦†ç›–ï¼Œå–å†…å®¹è¾¹ç•Œä¸â€œå»æ‰ body margin çš„æ•´é¡µâ€å¹¶é›†ï¼Œå†å°å¹…æ‰©å¤§
          if (EXPORT_MAX_COVERAGE) {
            try {
              const dv = iframeDoc.defaultView || window;
              const csBody = dv.getComputedStyle(iframeDoc.body);
              const mL = Math.max(0, Math.round(parseFloat(csBody.marginLeft) || 0));
              const mT = Math.max(0, Math.round(parseFloat(csBody.marginTop) || 0));
              const mR = Math.max(0, Math.round(parseFloat(csBody.marginRight) || 0));
              const mB = Math.max(0, Math.round(parseFloat(csBody.marginBottom) || 0));
              const pageRect = { x: mL, y: mT, w: Math.max(1, width - mL - mR), h: Math.max(1, height - mT - mB) };
              const left = Math.min(contentBounds.x, pageRect.x);
              const top = Math.min(contentBounds.y, pageRect.y);
              const right = Math.max(contentBounds.x + contentBounds.w, pageRect.x + pageRect.w);
              const bottom = Math.max(contentBounds.y + contentBounds.h, pageRect.y + pageRect.h);
              const bleed = Math.min(48, Math.max(8, Math.ceil(Math.min(width, height) * 0.008))); // çº¦0.8%~48px
              const x = Math.max(0, Math.floor(left - bleed));
              const y = Math.max(0, Math.floor(top - bleed));
              const w = Math.min(width - x, Math.max(1, Math.ceil((right - left) + bleed * 2)));
              const h = Math.min(height - y, Math.max(1, Math.ceil((bottom - top) + bleed * 2)));
              const merged = { x, y, w, h };
              Logger.log('æœ€å¤§è¦†ç›–å¹¶é›†è£åˆ‡', { pageRect, merged, bleed });
              contentBounds = merged;
            } catch (e) { Logger.warn('æœ€å¤§è¦†ç›–å¹¶é›†å¤±è´¥', e?.message || e); }
          }
        }

        // é¢„å–å¹¶å†…è”å¤–éƒ¨å›¾ç‰‡èµ„æºï¼ˆimg/src ä¸ CSS èƒŒæ™¯å›¾ï¼‰ï¼Œé¿å…è·¨åŸŸå¯¼è‡´å¯¼å‡ºç©ºç™½/ä¸å®Œæ•´
        const inlinedImageMap = {};
        try {
          const absUrl = (u) => {
            try { return new URL(u, iframeDoc.baseURI || window.location.href).href; } catch { return u; }
          };
          const isDataUrl = (u) => /^\s*data:/i.test(u || '');
          const isSvg = (u) => /\.svg(\?|$)/i.test(u || '');
          const isRaster = (u) => /\.(png|jpe?g|gif|webp|bmp|avif|tif?f)(\?|$)/i.test(u || '');
          const extractCssUrls = (val) => {
            if (!val || typeof val !== 'string') return [];
            const out = [];
            const re = /url\(([^)]+)\)/ig;
            let m;
            while ((m = re.exec(val))) {
              let raw = m[1].trim().replace(/^['"]/,'').replace(/['"]$/,'');
              if (!raw) continue;
              out.push(raw);
            }
            return out;
          };
          const toBase64 = (ab) => {
            const bytes = new Uint8Array(ab);
            let bin = '';
            const chunk = 0x8000;
            for (let i = 0; i < bytes.length; i += chunk) {
              bin += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
            }
            return btoa(bin);
          };
          const guessMimeFromUrl = (u) => {
            const lower = String(u || '').toLowerCase().split('?')[0].split('#')[0];
            if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
            if (lower.endsWith('.png')) return 'image/png';
            if (lower.endsWith('.gif')) return 'image/gif';
            if (lower.endsWith('.webp')) return 'image/webp';
            if (lower.endsWith('.bmp')) return 'image/bmp';
            if (lower.endsWith('.avif')) return 'image/avif';
            if (lower.endsWith('.tif') || lower.endsWith('.tiff')) return 'image/tiff';
            return 'application/octet-stream';
          };
          const fetchAsDataUrl = async (url) => {
            try {
              const res = await fetch(url, { mode: 'cors', credentials: 'omit', cache: 'force-cache' });
              if (!res.ok) return null;
              const buf = await res.arrayBuffer();
              const ctHeader = res.headers.get('content-type');
              const ct = (ctHeader && ctHeader.includes('/')) ? ctHeader : guessMimeFromUrl(url);
              return `data:${ct};base64,${toBase64(buf)}`;
            } catch { return null; }
          };


          const dv = iframeDoc.defaultView || window;
          const candidates = new Set();
          // æ”¶é›† <img src>
          Array.from(iframeDoc.images || []).forEach(img => {
            const src = (img.getAttribute('src') || '').trim();
            if (!src || isDataUrl(src) || isSvg(src)) return;
            candidates.add(absUrl(src));
          });
          // æ”¶é›† CSS èƒŒæ™¯å›¾
          const allEls = Array.from(iframeDoc.querySelectorAll('*'));
          allEls.forEach(el => {
            try {
              const cs = dv.getComputedStyle(el);
              ['backgroundImage','maskImage','borderImageSource'].forEach(prop => {
                const val = cs.getPropertyValue(prop);
                const urls = extractCssUrls(val);
                urls.forEach(u => { if (!isDataUrl(u) && !isSvg(u)) candidates.add(absUrl(u)); });
              });
            } catch {}
          });
          // é™åˆ¶æ•°é‡ï¼Œé¿å…è¿‡å¤§
          const MAX_FETCH = 64;
          const urlList = Array.from(candidates).slice(0, MAX_FETCH);
          await Promise.all(urlList.map(async (u) => {
            if (inlinedImageMap[u]) return;
            const data = await fetchAsDataUrl(u);
            if (data) inlinedImageMap[u] = data;
          }));
          console.log('[Export] inlined images:', Object.keys(inlinedImageMap).length);
          
          // å…³é”®ä¿®å¤ï¼šåœ¨åŸå§‹æ–‡æ¡£ä¸­å°±æ›¿æ¢æ‰€æœ‰å›¾ç‰‡ï¼Œé¿å… html2canvas å…‹éš†æ—¶åŠ è½½å¤±è´¥
          Array.from(iframeDoc.images || []).forEach(img => {
            try {
              const src = (img.getAttribute('src') || '').trim();
              if (!src || src.startsWith('data:')) return;
              const abs = absUrl(src);
              const data = inlinedImageMap[abs];
              if (data) {
                img.setAttribute('data-original-src', src);
                img.setAttribute('src', data);
              } else if (!src.startsWith('data:')) {
                // æ²¡æœ‰æˆåŠŸé¢„å–çš„å›¾ç‰‡ï¼Œç›´æ¥æ›¿æ¢ä¸ºé€æ˜å›¾
                img.setAttribute('data-original-src', src);
                img.setAttribute('src', 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7');
              }
            } catch {}
          });
          Logger.log('åŸå§‹æ–‡æ¡£å›¾ç‰‡å·²æ›¿æ¢', { total: iframeDoc.images.length });
        } catch (e) { console.warn('inline raster images failed', e); }

        // é¢„å–å¹¶å†…è” Font Awesome ç­‰ Web å­—ä½“ï¼Œé¿å…å¯¼å‡ºæ—¶å›¾æ ‡ä¸¢å¤±
        let inlinedFontCss = '';
        try {
          // æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„å­—ä½“æ ·å¼è¡¨ï¼ˆä¼˜å…ˆ Font Awesomeï¼‰
          const links = Array.from(iframeDoc.querySelectorAll('link[rel="stylesheet"]'));
          const fontCssLinks = links
            .map(l => l.href || l.getAttribute('href') || '')
            .filter(h => /font[- ]?awesome|all\.min\.css/i.test(h));

          const fetchText = async (url) => {
            try {
              const res = await fetch(url, { mode: 'cors', credentials: 'omit', cache: 'force-cache' });
              if (!res.ok) return null;
              return await res.text();
            } catch { return null; }
          };

          const toBase64 = (ab) => {
            const bytes = new Uint8Array(ab);
            let bin = '';
            const chunk = 0x8000;
            for (let i = 0; i < bytes.length; i += chunk) {
              bin += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
            }
            return btoa(bin);
          };

          const fetchFontAsDataUrl = async (baseHref, fontUrl) => {
            let abs;
            try { abs = new URL(fontUrl, baseHref).href; } catch { abs = fontUrl; }
            try {
              const res = await fetch(abs, { mode: 'cors', credentials: 'omit', cache: 'force-cache' });
              if (!res.ok) return null;
              const buf = await res.arrayBuffer();
              const b64 = toBase64(buf);
              const mime = /\.woff2(\?|$)/i.test(abs) ? 'font/woff2' : /\.woff(\?|$)/i.test(abs) ? 'font/woff' : 'application/octet-stream';
              return `data:${mime};base64,${b64}`;
            } catch { return null; }
          };

          const cssList = (await Promise.all(fontCssLinks.map(fetchText))).filter(Boolean);
          const inlinedList = [];
          for (let i = 0; i < cssList.length; i++) {
            const cssText = cssList[i];
            const baseHref = fontCssLinks[i];
            // ä»…å¤„ç† @font-face å—å¹¶æ›¿æ¢ url()
            const replaced = await (async () => {
              let out = cssText;
              // æ‰¾åˆ°æ‰€æœ‰ url(...) å¼•ç”¨
              const urlRegex = /url\(([^)]+)\)/ig;
              const refs = Array.from(cssText.matchAll(urlRegex)).map(m => ({ raw: m[0], url: m[1].replace(/[\"']/g, '').trim() }));
              // ä¼˜å…ˆæ›¿æ¢ woff2/woff
              for (const r of refs) {
                if (!/\.woff2?(\?|$)/i.test(r.url)) continue;
                const dataUrl = await fetchFontAsDataUrl(baseHref, r.url);
                if (dataUrl) {
                  out = out.split(r.raw).join(`url(${dataUrl})`);
                }
              }
              // å¼ºåˆ¶å¿«é€Ÿæ˜¾ç¤º
              out = out.replace(/font-display\s*:\s*[^;]+;/ig, 'font-display: swap;');
              return out;
            })();
            inlinedList.push(replaced);
          }
          inlinedFontCss = inlinedList.join('\n');
        } catch (e) { console.warn('inline fonts failed', e); }

        // é¢„å–å¤–éƒ¨ SVG èµ„æºï¼šsprite ä¸ <img src="*.svg">
        const externalSpriteMap = {};
        const externalSvgMap = {};
        try {
          const XLINK = 'http://www.w3.org/1999/xlink';
          const useNodes = Array.from(iframeDoc.querySelectorAll('use'));
          const spriteUrls = Array.from(new Set(useNodes.map(u => {
            let href = u.getAttribute('href') || u.getAttributeNS?.(XLINK, 'href');
            if (!href) return null;
            const i = href.indexOf('#');
            if (i <= 0) return null; // æ²¡æœ‰å¤–éƒ¨è·¯å¾„
            const base = href.slice(0, i);
            try { return new URL(base, window.location.href).href; } catch { return base; }
          }).filter(Boolean)));

          const imgNodes = Array.from(iframeDoc.querySelectorAll('img'))
            .filter(img => (img.getAttribute('src') || '').trim().toLowerCase().endsWith('.svg'));
          const svgUrls = Array.from(new Set(imgNodes.map(img => {
            const src = img.getAttribute('src');
            try { return new URL(src, window.location.href).href; } catch { return src; }
          }).filter(Boolean)));

          const fetchText = async (url) => {
            try {
              const res = await fetch(url, { mode: 'cors', credentials: 'omit', cache: 'force-cache' });
              if (!res.ok) return null;
              return await res.text();
            } catch { return null; }
          };

          await Promise.all([
            ...spriteUrls.map(async (u) => { const t = await fetchText(u); if (t) externalSpriteMap[u] = t; }),
            ...svgUrls.map(async (u) => { const t = await fetchText(u); if (t) externalSvgMap[u] = t; })
          ]);
        } catch (e) { console.warn('prefetch svg failed', e); }

        // å°† Font Awesome çš„ä¼ªå…ƒç´ å†…å®¹é¢„å¤„ç†ä¸ºçœŸå®æ–‡æœ¬ï¼Œé¿å…ä¸ªåˆ«ç¯å¢ƒä¸‹ ::before æœªè¢«æ¸²æŸ“
        try {
          const iconCandidates = Array.from(iframeDoc.querySelectorAll('i[class*="fa-"], span[class*="fa-"], .fa-solid, .fa-regular, .fa-brands'));
          iconCandidates.forEach(el => {
            try {
              const before = iframeDoc.defaultView?.getComputedStyle(el, '::before');
              const content = before?.getPropertyValue('content') || '';
              const fam = before?.getPropertyValue('font-family') || '';
              const weight = before?.getPropertyValue('font-weight') || '';
              if (content && content !== 'none' && content !== 'normal') {
                // å»é™¤åŒ…è£¹å¼•å·å¹¶è§£ç  \fXXXX è½¬ä¹‰
                const m = content.match(/^\s*['"](.*)['"]\s*$/);
                let glyph = m ? m[1] : content;
                try {
                  glyph = glyph.replace(/\\([0-9a-fA-F]{1,6})\s?/g, (_, hex) => String.fromCodePoint(parseInt(hex, 16)));
                } catch {}
                if (glyph && glyph !== '\\') {
                  el.setAttribute('data-fa-content', glyph);
                  if (fam) el.setAttribute('data-fa-font', fam);
                  if (weight) el.setAttribute('data-fa-weight', weight);
                }
              }
            } catch {}
          });
        } catch (e) { console.warn('prepare fa glyphs failed', e); }

        // ä»…ä½¿ç”¨ html2canvas åŒé€šé“æ¸²æŸ“ï¼Œé¿å… sandbox è„šæœ¬æŠ¥é”™
        // åŸºå‡†ç¼©æ”¾ç”¨ç”¨æˆ·åå¥½ï¼ˆé»˜è®¤2.5xï¼ŒAlt=3xï¼ŒShift=4xï¼‰
        const userHint = (() => {
          try {
            return {
              shift: !!(evt && evt.shiftKey),
              alt: !!(evt && (evt.altKey || evt.metaKey)),
              ctrl: !!(evt && evt.ctrlKey)
            };
          } catch { return { shift:false, alt:false, ctrl:false }; }
        })();
        const preferredScale = userHint.shift ? 4 : userHint.alt ? 3 : 2.5;
        // è¶…é‡‡æ ·ï¼ˆæŒ‰ä½ Ctrl/âŒ˜ï¼‰ï¼šæ›´é«˜å†…éƒ¨æ¸²æŸ“å€ç‡ï¼Œå¯¼å‡ºå‰å†é«˜è´¨é‡ä¸‹é‡‡æ ·
        const renderScale = userHint.ctrl ? Math.min(preferredScale * 1.75, preferredScale + 2) : preferredScale;
        const scale = renderScale;
        
        // åŠ¨æ€è®¡ç®—æœ€å¤§å°ºå¯¸é™åˆ¶ï¼Œæ ¹æ®å†…å®¹å®é™…å°ºå¯¸è‡ªé€‚åº”
        const aspectRatio = width / height;
        const isPortrait = aspectRatio < 0.8;
        const isLandscape = aspectRatio > 1.25;
        const isSquare = !isPortrait && !isLandscape;
        
        // æ ¹æ®å†…å®¹å°ºå¯¸å’Œé•¿å®½æ¯”åŠ¨æ€è°ƒæ•´ä¸Šé™
        let maxSide, maxPixels;
        if (contentSize < 600) {
          // å°å°ºå¯¸å†…å®¹ï¼šå…è®¸æ›´é«˜çš„æ”¾å¤§å€ç‡
          maxSide = 12000;
          maxPixels = 280 * 1024 * 1024;
        } else if (contentSize < 1500) {
          // ä¸­ç­‰å°ºå¯¸ï¼šæ ‡å‡†é™åˆ¶
          maxSide = 10000;
          maxPixels = 240 * 1024 * 1024;
        } else if (contentSize < 3500) {
          // è¾ƒå¤§å°ºå¯¸ï¼šç•¥å¾®æ”¶ç´§
          maxSide = 8192;
          maxPixels = 220 * 1024 * 1024;
        } else {
          // è¶…å¤§å°ºå¯¸ï¼šä¿å®ˆé™åˆ¶
          maxSide = 6144;
          maxPixels = 180 * 1024 * 1024;
        }
        
        // å¯¹äºæç«¯é•¿å®½æ¯”ï¼Œè¿›ä¸€æ­¥è°ƒæ•´
        if (aspectRatio > 3 || aspectRatio < 0.33) {
          maxSide = Math.floor(maxSide * 1.5); // æ”¾å®½å•è¾¹é™åˆ¶
          Logger.log('æ£€æµ‹åˆ°æç«¯é•¿å®½æ¯”ï¼Œè°ƒæ•´é™åˆ¶', { aspectRatio, maxSide });
        }
        
        const scaleBySide = maxSide / Math.max(width, height);
        const scaleByArea = Math.sqrt(maxPixels / Math.max(1, width * height));
        let scaleClamped = Math.min(scale, scaleBySide, scaleByArea);
        
        // åŠ¨æ€è°ƒæ•´æœ€å°ç¼©æ”¾ï¼šå°å†…å®¹å…è®¸æ›´é«˜ç¼©æ”¾ï¼Œå¤§å†…å®¹è®¾ç½®æ›´é«˜ä¸‹é™
        const minScale = contentSize < 600 ? 1.0 : contentSize < 1500 ? 0.75 : 0.5;
        scaleClamped = Math.max(minScale, scaleClamped);
        
        console.log('[Export] size=', { width, height, aspectRatio, maxSide, maxPixels, preferredScale, scaleClamped });
        Logger.log('ç¼©æ”¾è®¡ç®—', { preferredScale, scaleBySide, scaleByArea, scaleClamped, minScale });
        const SIMPLE_MODE = false;

        const renderWith = async (useFO) => {
          try {
            return await html2canvas(iframeDoc.documentElement, {
            scale: scaleClamped,
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#ffffff',
            logging: false,
            foreignObjectRendering: useFO,
            width: width,
            height: height,
            windowWidth: width,
            windowHeight: height,
            scrollX: 0,
            scrollY: 0,
            x: 0,
            y: 0,
            imageTimeout: 0,
            onclone: (clonedDoc, clonedWin) => {
              // å…¨å±€ç¦ç”¨é”™è¯¯äº‹ä»¶ï¼Œé˜²æ­¢å›¾ç‰‡åŠ è½½å¤±è´¥å¯¼è‡´å¯¼å‡ºä¸­æ–­
              try {
                clonedDoc.addEventListener('error', (e) => { e.preventDefault(); e.stopPropagation(); return false; }, true);
                if (clonedWin) {
                  clonedWin.onerror = () => false;
                  clonedWin.addEventListener('error', (e) => { e.preventDefault(); e.stopPropagation(); return false; }, true);
                }
              } catch {}
              
              // åŸºæœ¬æ¸…ç†
              clonedDoc.querySelectorAll('script').forEach(s => s.remove());
              clonedDoc.querySelectorAll('*').forEach(el => {
                for (const a of Array.from(el.attributes)) {
                  if (/^on/i.test(a.name)) el.removeAttribute(a.name);
                }
              });
              // åº”ç”¨å·²é¢„å–çš„ä½å›¾èµ„æºï¼šæ›¿æ¢ CSS èƒŒæ™¯å›¾åˆ° data:URLï¼Œé¿å…è·¨åŸŸæ±¡æŸ“
              // æ³¨æ„ï¼š<img> å·²åœ¨åŸå§‹æ–‡æ¡£ä¸­æ›¿æ¢ï¼Œè¿™é‡Œåªå¤„ç† CSS èƒŒæ™¯
              try {
                const dv2 = clonedDoc.defaultView || window;
                const replaceCssUrls = (val) => {
                  if (!val || typeof val !== 'string') return val;
                  return val.replace(/url\(([^)]+)\)/ig, (m, p1) => {
                    let raw = String(p1).trim().replace(/^['"]/,'').replace(/['"]$/,'');
                    const abs = (() => { try { return new URL(raw, clonedDoc.baseURI || window.location.href).href; } catch { return raw; } })();
                    const data = inlinedImageMap[abs];
                    if (data) return `url("${data}")`;
                    return m;
                  });
                };
                // CSS èƒŒæ™¯å›¾æ›¿æ¢
                Array.from(clonedDoc.querySelectorAll('*')).forEach(el => {
                  try {
                    const cs = dv2.getComputedStyle(el);
                    const bg = cs.getPropertyValue('background-image');
                    const mask = cs.getPropertyValue('mask-image');
                    const borderImg = cs.getPropertyValue('border-image-source');
                    const bg2 = replaceCssUrls(bg);
                    const mask2 = replaceCssUrls(mask);
                    const border2 = replaceCssUrls(borderImg);
                    if (bg2 && bg2 !== bg) el.style.backgroundImage = bg2;
                    if (mask2 && mask2 !== mask) el.style.maskImage = mask2;
                    if (border2 && border2 !== borderImg) el.style.borderImageSource = border2;
                  } catch {}
                });
              } catch {}
              if (!SIMPLE_MODE) {
                try {
                  if (inlinedFontCss) {
                    const s = clonedDoc.createElement('style');
                    s.setAttribute('data-inline-fonts', 'true');
                    s.textContent = inlinedFontCss;
                    clonedDoc.head.insertBefore(s, clonedDoc.head.firstChild || null);
                    Array.from(clonedDoc.querySelectorAll('link[rel="stylesheet"]')).forEach(l => {
                      const href = l.href || l.getAttribute('href') || '';
                      if (/font[- ]?awesome|all\.min\.css/i.test(href)) l.remove();
                    });
                  }
                } catch {}
                try {
                  const nodes = Array.from(clonedDoc.querySelectorAll('[data-fa-content]'));
                  nodes.forEach(el => {
                    if (!el.textContent || !el.textContent.trim()) {
                      const glyph = el.getAttribute('data-fa-content');
                      const fam = el.getAttribute('data-fa-font') || 'Font Awesome 6 Free, Font Awesome 6 Pro, Font Awesome 5 Free';
                      const weight = el.getAttribute('data-fa-weight') || '900';
                      const span = clonedDoc.createElement('span');
                      span.textContent = glyph;
                      span.style.fontFamily = fam;
                      span.style.fontWeight = weight;
                      span.style.fontStyle = 'normal';
                      span.style.lineHeight = '1';
                      span.style.display = 'inline-block';
                      span.style.webkitFontSmoothing = 'antialiased';
                      span.style.mozOsxFontSmoothing = 'grayscale';
                      el.appendChild(span);
                    }
                    el.removeAttribute('data-fa-content');
                    el.removeAttribute('data-fa-font');
                    el.removeAttribute('data-fa-weight');
                  });
                } catch {}
                try {
                  const dv2 = clonedDoc.defaultView || window;
                  const els = Array.from(clonedDoc.querySelectorAll('*'));
                  els.forEach(el => {
                    try {
                      const st = dv2.getComputedStyle(el);
                      const oy = st.overflowY, ox = st.overflowX;
                      const needY = (oy === 'auto' || oy === 'scroll' || oy === 'hidden') && (el.scrollHeight - el.clientHeight > 2);
                      const needX = (ox === 'auto' || ox === 'scroll' || ox === 'hidden') && (el.scrollWidth - el.clientWidth > 2);
                      if (needY) {
                        el.style.minHeight = '0';
                        el.style.maxHeight = 'none';
                        el.style.height = el.scrollHeight + 'px';
                        el.style.overflowY = 'visible';
                      }
                      if (needX) {
                        el.style.minWidth = '0';
                        el.style.maxWidth = 'none';
                        el.style.width = Math.max(el.scrollWidth, el.clientWidth) + 'px';
                        el.style.overflowX = 'visible';
                      }
                    } catch {}
                  });
                } catch {}
                try {
                  const XLINK = 'http://www.w3.org/1999/xlink';
                  const svgNS = 'http://www.w3.org/2000/svg';
                  const parser = new DOMParser();
                  const uses = Array.from(clonedDoc.querySelectorAll('use'));
                  uses.forEach(u => {
                    let href = u.getAttribute('href') || u.getAttributeNS?.(XLINK, 'href');
                    if (!href) return;
                    const idx = href.indexOf('#');
                    if (idx === -1) return;
                    const base = href.slice(0, idx);
                    const symbolId = href.slice(idx + 1);
                    let target = null;
                    if (!base) {
                      target = clonedDoc.getElementById(symbolId);
                    } else {
                      const xml = externalSpriteMap[(() => { try { return new URL(base, window.location.href).href; } catch { return base; } })()];
                      if (xml) {
                        const spriteDoc = parser.parseFromString(xml, 'image/svg+xml');
                        target = spriteDoc.getElementById(symbolId);
                      }
                    }
                    if (!target) return;
                    const wrapper = clonedDoc.createElementNS(svgNS, 'svg');
                    const vb = target.getAttribute('viewBox');
                    if (vb) wrapper.setAttribute('viewBox', vb);
                    ['x','y','width','height','transform'].forEach(a => { if (u.hasAttribute(a)) wrapper.setAttribute(a, u.getAttribute(a)); });
                    if (u.getAttribute('class')) wrapper.setAttribute('class', u.getAttribute('class'));
                    if (u.getAttribute('style')) wrapper.setAttribute('style', u.getAttribute('style'));
                    Array.from(target.childNodes).forEach(ch => wrapper.appendChild(ch.cloneNode(true)));
                    u.replaceWith(wrapper);
                  });
                } catch {}
                try {
                  const parser = new DOMParser();
                  const imgs = Array.from(clonedDoc.querySelectorAll('img'));
                  imgs.forEach(img => {
                    const src = img.getAttribute('src') || '';
                    const lower = src.toLowerCase();
                    let svgText = null;
                    if (lower.startsWith('data:image/svg+xml')) {
                      const comma = src.indexOf(',');
                      const meta = src.slice(0, comma).toLowerCase();
                      const payload = src.slice(comma + 1);
                      try {
                        svgText = meta.includes(';base64') ? atob(payload) : decodeURIComponent(payload);
                      } catch {}
                    } else if (lower.endsWith('.svg')) {
                      let abs;
                      try { abs = new URL(src, window.location.href).href; } catch { abs = src; }
                      svgText = externalSvgMap[abs] || null;
                    }
                    if (!svgText) return;
                    const doc = parser.parseFromString(svgText, 'image/svg+xml');
                    const svgEl = doc.documentElement;
                    if (!svgEl || svgEl.nodeName.toLowerCase() !== 'svg') return;
                    const newSvg = clonedDoc.importNode(svgEl, true);
                    if (img.getAttribute('width')) newSvg.setAttribute('width', img.getAttribute('width'));
                    if (img.getAttribute('height')) newSvg.setAttribute('height', img.getAttribute('height'));
                    if (!newSvg.getAttribute('width') && img.width) newSvg.setAttribute('width', String(img.width));
                    if (!newSvg.getAttribute('height') && img.height) newSvg.setAttribute('height', String(img.height));
                    img.replaceWith(newSvg);
                  });
                } catch {}
              }
            }
          });
          } catch (renderErr) {
            console.warn('[Export] html2canvasæ¸²æŸ“å¤±è´¥:', renderErr);
            Logger.warn('html2canvasæ¸²æŸ“å¤±è´¥', { message: renderErr?.message });
            throw renderErr;
          }
        };

        const renderTiled = async () => {
          // æ ¹æ®å†…å®¹å°ºå¯¸åŠ¨æ€è®¡ç®—åˆ†å—å¤§å°
          const baseTileLimit = contentSize < 1500 ? 10000 : contentSize < 3500 ? 8000 : 6000;
          const tileLimit = Math.min(baseTileLimit, maxSide);
          const minTileH = Math.max(128, Math.floor(height * 0.05)); // è‡³å°‘5%çš„é«˜åº¦
          const tileH = Math.max(minTileH, Math.floor(tileLimit / Math.max(0.5, scaleClamped)));
          Logger.log('åˆ†å—æ¸²æŸ“å‚æ•°', { tileLimit, tileH, minTileH });
          const out = document.createElement('canvas');
          const outW = Math.max(1, Math.floor(width * scaleClamped));
          const outH = Math.max(1, Math.floor(height * scaleClamped));
          out.width = outW; out.height = outH;
          const octx = out.getContext('2d', { alpha: false });
          octx.fillStyle = '#ffffff';
          octx.fillRect(0, 0, outW, outH);
          let y = 0;
          while (y < height) {
            const h = Math.min(tileH, height - y);
            const cv = await html2canvas(iframeDoc.documentElement, {
              scale: scaleClamped,
              useCORS: true,
              allowTaint: true,
              backgroundColor: '#ffffff',
              logging: false,
              foreignObjectRendering: false,
              width: width,
              height: h,
              windowWidth: width,
              windowHeight: height,
              scrollX: 0,
              scrollY: 0,
              x: 0,
              y: y,
              imageTimeout: 0,
              onclone: (clonedDoc, clonedWin) => {
                // å…¨å±€ç¦ç”¨é”™è¯¯äº‹ä»¶ï¼Œé˜²æ­¢å›¾ç‰‡åŠ è½½å¤±è´¥å¯¼è‡´å¯¼å‡ºä¸­æ–­
                try {
                  clonedDoc.addEventListener('error', (e) => { e.preventDefault(); e.stopPropagation(); return false; }, true);
                  if (clonedWin) {
                    clonedWin.onerror = () => false;
                    clonedWin.addEventListener('error', (e) => { e.preventDefault(); e.stopPropagation(); return false; }, true);
                  }
                } catch {}
                
                clonedDoc.querySelectorAll('script').forEach(s => s.remove());
                clonedDoc.querySelectorAll('*').forEach(el => {
                  for (const a of Array.from(el.attributes)) {
                    if (/^on/i.test(a.name)) el.removeAttribute(a.name);
                  }
                });
                // åº”ç”¨ä½å›¾èµ„æºå†…è”ï¼Œç¡®ä¿åˆ‡ç‰‡æ¸²æŸ“åŒæ ·å®Œæ•´
                // æ³¨æ„ï¼š<img> å·²åœ¨åŸå§‹æ–‡æ¡£ä¸­æ›¿æ¢ï¼Œè¿™é‡Œåªå¤„ç† CSS èƒŒæ™¯
                try {
                  const dv2 = clonedDoc.defaultView || window;
                  const replaceCssUrls = (val) => {
                    if (!val || typeof val !== 'string') return val;
                    return val.replace(/url\(([^)]+)\)/ig, (m, p1) => {
                      let raw = String(p1).trim().replace(/^['"]/,'').replace(/['"]$/,'');
                      const abs = (() => { try { return new URL(raw, clonedDoc.baseURI || window.location.href).href; } catch { return raw; } })();
                      const data = inlinedImageMap[abs];
                      if (data) return `url("${data}")`;
                      return m;
                    });
                  };
                  Array.from(clonedDoc.querySelectorAll('*')).forEach(el => {
                    try {
                      const cs = dv2.getComputedStyle(el);
                      const bg = cs.getPropertyValue('background-image');
                      const mask = cs.getPropertyValue('mask-image');
                      const borderImg = cs.getPropertyValue('border-image-source');
                      const bg2 = replaceCssUrls(bg);
                      const mask2 = replaceCssUrls(mask);
                      const border2 = replaceCssUrls(borderImg);
                      if (bg2 && bg2 !== bg) el.style.backgroundImage = bg2;
                      if (mask2 && mask2 !== mask) el.style.maskImage = mask2;
                      if (border2 && border2 !== borderImg) el.style.borderImageSource = border2;
                    } catch {}
                  });
                } catch {}
                try {
                  if (inlinedFontCss) {
                    const s = clonedDoc.createElement('style');
                    s.setAttribute('data-inline-fonts', 'true');
                    s.textContent = inlinedFontCss;
                    clonedDoc.head.insertBefore(s, clonedDoc.head.firstChild || null);
                    Array.from(clonedDoc.querySelectorAll('link[rel="stylesheet"]')).forEach(l => {
                      const href = l.href || l.getAttribute('href') || '';
                      if (/font[- ]?awesome|all\.min\.css/i.test(href)) l.remove();
                    });
                  }
                } catch {}
                try {
                  const nodes = Array.from(clonedDoc.querySelectorAll('[data-fa-content]'));
                  nodes.forEach(el => {
                    if (!el.textContent || !el.textContent.trim()) {
                      const glyph = el.getAttribute('data-fa-content');
                      const fam = el.getAttribute('data-fa-font') || 'Font Awesome 6 Free, Font Awesome 6 Pro, Font Awesome 5 Free';
                      const weight = el.getAttribute('data-fa-weight') || '900';
                      const span = clonedDoc.createElement('span');
                      span.textContent = glyph;
                      span.style.fontFamily = fam;
                      span.style.fontWeight = weight;
                      span.style.fontStyle = 'normal';
                      span.style.lineHeight = '1';
                      span.style.display = 'inline-block';
                      span.style.webkitFontSmoothing = 'antialiased';
                      span.style.mozOsxFontSmoothing = 'grayscale';
                      el.appendChild(span);
                    }
                    el.removeAttribute('data-fa-content');
                    el.removeAttribute('data-fa-font');
                    el.removeAttribute('data-fa-weight');
                  });
                } catch {}
                try {
                  const dv2 = clonedDoc.defaultView || window;
                  const els = Array.from(clonedDoc.querySelectorAll('*'));
                  els.forEach(el => {
                    try {
                      const st = dv2.getComputedStyle(el);
                      const oy = st.overflowY, ox = st.overflowX;
                      const needY = (oy === 'auto' || oy === 'scroll' || oy === 'hidden') && (el.scrollHeight - el.clientHeight > 2);
                      const needX = (ox === 'auto' || ox === 'scroll' || ox === 'hidden') && (el.scrollWidth - el.clientWidth > 2);
                      if (needY) {
                        el.style.minHeight = '0';
                        el.style.maxHeight = 'none';
                        el.style.height = el.scrollHeight + 'px';
                        el.style.overflowY = 'visible';
                      }
                      if (needX) {
                        el.style.minWidth = '0';
                        el.style.maxWidth = 'none';
                        el.style.width = Math.max(el.scrollWidth, el.clientWidth) + 'px';
                        el.style.overflowX = 'visible';
                      }
                    } catch {}
                  });
                } catch {}
                try {
                  const XLINK = 'http://www.w3.org/1999/xlink';
                  const svgNS = 'http://www.w3.org/2000/svg';
                  const parser = new DOMParser();
                  const uses = Array.from(clonedDoc.querySelectorAll('use'));
                  uses.forEach(u => {
                    let href = u.getAttribute('href') || u.getAttributeNS(XLINK, 'href');
                    if (!href) return;
                    const idx = href.indexOf('#');
                    if (idx === -1) return;
                    const base = href.slice(0, idx);
                    const symbolId = href.slice(idx + 1);
                    let target = null;
                    if (!base) {
                      target = clonedDoc.getElementById(symbolId);
                    } else {
                      const xml = externalSpriteMap[(() => { try { return new URL(base, window.location.href).href; } catch { return base; } })()];
                      if (xml) {
                        const spriteDoc = parser.parseFromString(xml, 'image/svg+xml');
                        target = spriteDoc.getElementById(symbolId);
                      }
                    }
                    if (!target) return;
                    const wrapper = clonedDoc.createElementNS(svgNS, 'svg');
                    const vb = target.getAttribute('viewBox');
                    if (vb) wrapper.setAttribute('viewBox', vb);
                    ['x','y','width','height','transform'].forEach(a => { if (u.hasAttribute(a)) wrapper.setAttribute(a, u.getAttribute(a)); });
                    if (u.getAttribute('class')) wrapper.setAttribute('class', u.getAttribute('class'));
                    if (u.getAttribute('style')) wrapper.setAttribute('style', u.getAttribute('style'));
                    Array.from(target.childNodes).forEach(ch => wrapper.appendChild(ch.cloneNode(true)));
                    u.replaceWith(wrapper);
                  });
                } catch {}
                try {
                  const parser = new DOMParser();
                  const imgs = Array.from(clonedDoc.querySelectorAll('img'));
                  imgs.forEach(img => {
                    const src = img.getAttribute('src') || '';
                    const lower = src.toLowerCase();
                    let svgText = null;
                    if (lower.startsWith('data:image/svg+xml')) {
                      const comma = src.indexOf(',');
                      const meta = src.slice(0, comma).toLowerCase();
                      const payload = src.slice(comma + 1);
                      try {
                        svgText = meta.includes(';base64') ? atob(payload) : decodeURIComponent(payload);
                      } catch {}
                    } else if (lower.endsWith('.svg')) {
                      let abs;
                      try { abs = new URL(src, window.location.href).href; } catch { abs = src; }
                      svgText = externalSvgMap[abs] || null;
                    }
                    if (!svgText) return;
                    const doc2 = parser.parseFromString(svgText, 'image/svg+xml');
                    const svgEl = doc2.documentElement;
                    if (!svgEl || svgEl.nodeName.toLowerCase() !== 'svg') return;
                    const newSvg = clonedDoc.importNode(svgEl, true);
                    if (img.getAttribute('width')) newSvg.setAttribute('width', img.getAttribute('width'));
                    if (img.getAttribute('height')) newSvg.setAttribute('height', img.getAttribute('height'));
                    if (!newSvg.getAttribute('width') && img.width) newSvg.setAttribute('width', String(img.width));
                    if (!newSvg.getAttribute('height') && img.height) newSvg.setAttribute('height', String(img.height));
                    img.replaceWith(newSvg);
                  });
                } catch {}
              }
            });
            octx.drawImage(cv, 0, Math.floor(y * scaleClamped));
            y += h;
          }
          return out;
        };

        // åŠ¨æ€è®¡ç®— FO å’Œåˆ†å—æ¸²æŸ“é˜ˆå€¼
        const FO_LIMIT = Math.min(16000, Math.max(8000, maxSide * 1.5)); // æ ¹æ® maxSide åŠ¨æ€è°ƒæ•´
        const allowFO = (width * scaleClamped <= FO_LIMIT && height * scaleClamped <= FO_LIMIT);
        const tileSideLimit = Math.max(6144, maxSide * 0.75);
        const tilePixelLimit = Math.max(120 * 1024 * 1024, maxPixels * 0.6);
        const needTile = (!allowFO) && ((width * scaleClamped > tileSideLimit) || (height * scaleClamped > tileSideLimit) || ((width * scaleClamped) * (height * scaleClamped) > tilePixelLimit));
        Logger.log('æ¸²æŸ“ç­–ç•¥', { allowFO, needTile, FO_LIMIT, tileSideLimit, tilePixelLimit });
        const PREFER_EFFECTS = true; // ä¼˜å…ˆä¿ç•™é˜´å½±ç­‰è§†è§‰æ•ˆæœ
        const scoreCanvasDetail = (cv) => {
          try {
            const w = cv.width, h = cv.height; if (!w || !h) return 0;
            const ctx = cv.getContext('2d');
            const stepX = Math.max(4, Math.floor(w / 96));
            const stepY = Math.max(4, Math.floor(h / 96));
            let score = 0;
            for (let y = stepY; y < h - stepY; y += stepY) {
              const row = ctx.getImageData(0, y, w, 1).data;
              for (let x = stepX * 4; x < (w - stepX) * 4; x += stepX * 4) {
                const r = row[x], g = row[x + 1], b = row[x + 2];
                const r2 = row[x - stepX * 4], g2 = row[x - stepX * 4 + 1], b2 = row[x - stepX * 4 + 2];
                const dr = Math.abs(r - r2), dg = Math.abs(g - g2), db = Math.abs(b - b2);
                score += dr + dg + db;
              }
            }
            return score;
          } catch { return 0; }
        };
        let canvas;
        try {
          if (needTile || !PREFER_EFFECTS) {
            canvas = needTile ? await renderTiled() : await renderWith(allowFO);
          } else {
            // åŒæ—¶å°è¯• FO å’ŒéFOï¼Œé€‰ç»†èŠ‚æ›´å¤šçš„ç»“æœ
            const c1 = await renderWith(true);
            const c2 = await renderWith(false);
            const s1 = scoreCanvasDetail(c1);
            const s2 = scoreCanvasDetail(c2);
            canvas = s1 >= s2 ? c1 : c2;
            Logger.log('æ•ˆæœä¼˜å…ˆé€‰æ‹©', { sFO: s1, sCanvas: s2, chosen: s1 >= s2 ? 'FO' : 'Canvas' });
          }
          Logger.log('æ¸²æŸ“å®Œæˆ', { width, height, scale: scaleClamped, tiled: needTile });
        } catch (canvasErr) {
          console.warn('[Export] Canvasæ¸²æŸ“å¼‚å¸¸ï¼Œå°è¯•é™çº§æ¸²æŸ“:', canvasErr);
          Logger.warn('Canvasæ¸²æŸ“å¼‚å¸¸ï¼Œå°è¯•é™çº§', { message: canvasErr?.message });
          // é™çº§ï¼šä½¿ç”¨æœ€ç®€å•çš„æ¸²æŸ“æ¨¡å¼
          canvas = await renderWith(false);
          Logger.log('é™çº§æ¸²æŸ“å®Œæˆ');
        }

        // ç®€å•ç™½å±æ£€æµ‹ï¼ˆå…¨ç™½/å…¨é€æ˜ï¼‰
        const nearlyWhite = (cv) => {
          try {
            if (!cv || !cv.width || !cv.height) return true;
            const ctx = cv.getContext('2d');
            const sample = ctx.getImageData(0, 0, Math.min(80, cv.width), Math.min(80, cv.height)).data;
            for (let i = 0; i < sample.length; i += 4) {
              const a = sample[i + 3];
              if (a > 5) {
                const r = sample[i], g = sample[i + 1], b = sample[i + 2];
                if (!(r > 245 && g > 245 && b > 245)) return false;
              }
            }
            return true;
          } catch { return false; }
        };

        if (allowFO && nearlyWhite(canvas)) {
          console.warn('foreignObject æ¸²æŸ“å¯èƒ½å¤±è´¥ï¼Œåˆ‡æ¢åˆ° canvas æ¸²æŸ“');
          canvas = await renderWith(false);
        }

        const cropWithBleed = (cv, bounds, bleed, scale, docWpx, docHpx) => {
          try {
            // è®¡ç®—ä¸¤ä¾§ä¸ä¸Šä¸‹çš„å¯ç”¨ç©ºé—´ï¼Œå¹¶å°†å‡ºè¡€é‡é™åˆ¶ä¸ºâ€œå¯ç”¨ç©ºé—´çš„æœ€å°å€¼â€ï¼Œä¿è¯å·¦å³/ä¸Šä¸‹å°½é‡å¯¹ç§°
            const leftSpace = Math.max(0, Math.floor(bounds.x));
            const topSpace = Math.max(0, Math.floor(bounds.y));
            const rightSpace = Math.max(0, Math.floor(docWpx - (bounds.x + bounds.w)));
            const bottomSpace = Math.max(0, Math.floor(docHpx - (bounds.y + bounds.h)));
            const bleedX = Math.min(Math.max(0, bleed), leftSpace, rightSpace);
            const bleedY = Math.min(Math.max(0, bleed), topSpace, bottomSpace);

            let x = Math.max(0, Math.floor(bounds.x - bleedX));
            let y = Math.max(0, Math.floor(bounds.y - bleedY));
            let w = Math.min(docWpx - x, Math.max(1, Math.ceil(bounds.w + bleedX * 2)));
            let h = Math.min(docHpx - y, Math.max(1, Math.ceil(bounds.h + bleedY * 2)));

            // å‘å†…å–æ•´èµ·ç‚¹ï¼Œå–æ¶ˆé¢å¤–åƒç´ å®¹å·®ï¼Œé¿å…å³/ä¸‹å‡ºç°å¤šä½™1-2pxç™½è¾¹
            const pixelTolerance = 0;
            const sx = Math.max(0, Math.ceil(x * scale));
            const sy = Math.max(0, Math.ceil(y * scale));
            const sw = Math.max(1, Math.round(w * scale + pixelTolerance));
            const sh = Math.max(1, Math.round(h * scale + pixelTolerance));

            const out = document.createElement('canvas');
            out.width = sw; out.height = sh;
            const ctx = out.getContext('2d', { alpha: false });
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(cv, sx, sy, sw, sh, 0, 0, sw, sh);
            
            // è®¡ç®—éœ€è¦è¡¥é½çš„é¡¶éƒ¨ç•™ç™½ï¼ˆä½¿é¡¶éƒ¨ä¸åº•éƒ¨ä¸€è‡´ï¼‰
            const currentTopPad = Math.round(y * scale);
            const currentBottomPad = Math.round((docHpx - (y + h)) * scale);
            const extraTopPad = Math.max(0, currentBottomPad - currentTopPad);

            // å¦‚æœéœ€è¦è¡¥é½é¡¶éƒ¨ç•™ç™½ï¼Œåˆ›å»ºæ–°canvas
            if (extraTopPad > 0) {
              const padded = document.createElement('canvas');
              padded.width = sw;
              padded.height = sh + extraTopPad;
              const pctx = padded.getContext('2d', { alpha: false });
              pctx.fillStyle = '#ffffff';
              pctx.fillRect(0, 0, padded.width, padded.height);
              pctx.imageSmoothingEnabled = true;
              pctx.imageSmoothingQuality = 'high';
              pctx.drawImage(out, 0, extraTopPad);
              return padded;
            }
            
            return out;
          } catch { return cv; }
        };
        const downscaleCanvas = (cv, ratio) => {
          try {
            if (!cv || ratio >= 1) return cv;
            const w = Math.max(1, Math.floor(cv.width * ratio));
            const h = Math.max(1, Math.floor(cv.height * ratio));
            const out = document.createElement('canvas');
            out.width = w; out.height = h;
            const ctx = out.getContext('2d', { alpha: false });
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(cv, 0, 0, cv.width, cv.height, 0, 0, w, h);
            return out;
          } catch { return cv; }
        };
        // å…ˆè£æ‰é¡µé¢å¤–è¾¹è·ï¼ˆæ— è¾¹æ¡†ï¼‰ï¼Œå†è¿›è¡Œå¯é€‰çš„è¶…é‡‡æ ·ä¸‹é‡‡æ ·ä»¥æå‡é”åº¦
        const dynamicBleed = Math.max(EXPORT_BLEED, 0);
        let outCanvas = cropWithBleed(canvas, contentBounds, dynamicBleed, scaleClamped, width, height);
        let postRatio = 1;
        if (scaleClamped > preferredScale * 1.02) {
          const ratio = Math.max(0.1, Math.min(1, preferredScale / scaleClamped));
          outCanvas = downscaleCanvas(outCanvas, ratio);
          postRatio = ratio;
        }
        // æ— è¾¹è·æ¨¡å¼ä¸‹ï¼šå†åšä¸€æ¬¡åƒç´ çº§è¾¹ç¼˜ä¿®å‰ªï¼ŒåŸºäºâ€œèƒŒæ™¯è‰²â€è‡ªé€‚åº”ï¼ˆä¸å±€é™ç™½è‰²/ç±³è‰²ï¼‰
        try {
          const wantNoBorder = String(borderSelect?.value || '0') === '0';
          if (wantNoBorder && ADV_TRIM_EDGES) {
            const trimBackgroundEdges = (cv) => {
              try {
                const w = cv.width, h = cv.height;
                if (!w || !h) return cv;
                const ctx = cv.getContext('2d');
                // æ ¹æ®å›¾ç‰‡å°ºå¯¸åŠ¨æ€è°ƒæ•´è£å‰ªå‚æ•°
                const MAX = Math.min(512, Math.max(64, Math.floor(Math.min(w, h) * 0.15))); // æœ€å¤šè£å‰ª15%
                const TOL = 28;            // é¢œè‰²å®¹å·®ï¼ˆæ¯é€šé“ï¼‰æ›´å®½æ¾ï¼Œå…¼å®¹è½»å¾®é˜´å½±
                const sample = (x, y) => {
                  const d = ctx.getImageData(x, y, 1, 1).data; return [d[0], d[1], d[2], d[3]];
                };
                const near = (r,g,b,a, rb,gb,bb,ab) => (a < 10) || (Math.abs(r-rb) <= TOL && Math.abs(g-gb) <= TOL && Math.abs(b-bb) <= TOL);
                // ä»¥å››è§’é¢œè‰²ä½œä¸ºå„è¾¹èƒŒæ™¯å‚è€ƒ
                const topBg = sample(0,0);
                const leftBg = sample(0,0);
                const rightBg = sample(w-1, 0);
                const bottomBg = sample(0, h-1);
                const rowIsBg = (y, bg) => {
                  const d = ctx.getImageData(0, y, w, 1).data;
                  let bgCount = 0, total = d.length / 4;
                  for (let i = 0; i < d.length; i += 4) {
                    if (near(d[i], d[i+1], d[i+2], d[i+3], bg[0], bg[1], bg[2], bg[3])) bgCount++;
                  }
                  return bgCount / total >= 0.98; // è‡³å°‘98%ä¸ºèƒŒæ™¯
                };
                const colIsBg = (x, bg) => {
                  const d = ctx.getImageData(x, 0, 1, h).data;
                  let bgCount = 0, total = d.length / 4;
                  for (let i = 0; i < d.length; i += 4) {
                    if (near(d[i], d[i+1], d[i+2], d[i+3], bg[0], bg[1], bg[2], bg[3])) bgCount++;
                  }
                  return bgCount / total >= 0.98;
                };
                let top = 0, bottom = 0, left = 0, right = 0;
                while (top < Math.min(MAX, h - 1) && rowIsBg(top, topBg)) top++;
                while (bottom < Math.min(MAX, h - 1 - top) && rowIsBg(h - 1 - bottom, bottomBg)) bottom++;
                while (left < Math.min(MAX, w - 1) && colIsBg(left, leftBg)) left++;
                while (right < Math.min(MAX, w - 1 - left) && colIsBg(w - 1 - right, rightBg)) right++;
                const fracRowBg = (y, bg) => {
                  const d = ctx.getImageData(0, y, w, 1).data; let c = 0; for (let i=0;i<d.length;i+=4){ if(near(d[i],d[i+1],d[i+2],d[i+3], bg[0],bg[1],bg[2],bg[3])) c++; } return c/(d.length/4);
                };
                const fracColBg = (x, bg) => {
                  const d = ctx.getImageData(x, 0, 1, h).data; let c = 0; for (let i=0;i<d.length;i+=4){ if(near(d[i],d[i+1],d[i+2],d[i+3], bg[0],bg[1],bg[2],bg[3])) c++; } return c/(d.length/4);
                };
                let extraTop = 0, extraLeft = 0;
                while (extraTop < 4 && top < h-1 && fracRowBg(top, topBg) >= 0.85) { top++; extraTop++; }
                while (extraLeft < 4 && left < w-1 && fracColBg(left, leftBg) >= 0.85) { left++; extraLeft++; }
                // ä½¿é¡¶éƒ¨å’Œåº•éƒ¨ç•™ç™½ä¸€è‡´ï¼šå–ä¸¤è€…ä¸­è¾ƒå°çš„è£å‰ªé‡
                const verticalTrim = Math.min(top, bottom);
                top = verticalTrim;
                bottom = verticalTrim;
                // ä½¿å·¦å³ç•™ç™½ä¸€è‡´ï¼šå–ä¸¤è€…ä¸­è¾ƒå°çš„è£å‰ªé‡
                const horizontalTrim = Math.min(left, right);
                left = horizontalTrim;
                right = horizontalTrim;
                
                if (left || right || top || bottom) {
                  const out = document.createElement('canvas');
                  const nw = Math.max(1, w - left - right);
                  const nh = Math.max(1, h - top - bottom);
                  out.width = nw; out.height = nh;
                  out.getContext('2d').drawImage(cv, left, top, nw, nh, 0, 0, nw, nh);
                  return out;
                }
                return cv;
              } catch { return cv; }
            };
            outCanvas = trimBackgroundEdges(outCanvas);
            // è·³è¿‡é¢å¤–çš„å•è¾¹è£å‰ªï¼Œä¿æŒé¡¶éƒ¨å’Œåº•éƒ¨ç•™ç™½ä¸€è‡´
          } else {
            Logger.log('è·³è¿‡èƒŒæ™¯å»è¾¹è£åˆ‡', { wantNoBorder, ADV_TRIM_EDGES });
          }
        } catch {}
        // é¢å¤–å¼ºå‰ªï¼šå†ä»å·¦ä¸ä¸Šå„å¤šè£ 2pxï¼ŒæŠ¹æ‰æçª„ç¼éš™
        if (FORCE_EXTRA_TRIM) {
          try {
            const cv3 = outCanvas; const w3 = cv3.width, h3 = cv3.height;
            if (w3 > 2 && h3 > 2) {
              const out = document.createElement('canvas');
              out.width = w3 - 2; out.height = h3 - 2;
              out.getContext('2d').drawImage(cv3, 2, 2, w3 - 2, h3 - 2, 0, 0, w3 - 2, h3 - 2);
              outCanvas = out;
            }
          } catch {}
        }
        // ç»Ÿä¸€å››è¾¹ç•™ç™½ï¼ˆå¯¼å‡ºåƒç´ ï¼‰ï¼Œç”±â€œè¾¹è·â€é€‰æ‹©æ§åˆ¶
        try {
          const pad = Math.max(0, parseInt(borderSelect?.value || '0', 10) || 0);
          if (pad > 0) {
            const padded = document.createElement('canvas');
            padded.width = outCanvas.width + pad * 2;
            padded.height = outCanvas.height + pad * 2;
            const pctx = padded.getContext('2d', { alpha: false });
            pctx.fillStyle = '#ffffff';
            pctx.fillRect(0, 0, padded.width, padded.height);
            pctx.drawImage(outCanvas, pad, pad);
            outCanvas = padded;
          }
        } catch {}
        outCanvas.toBlob((blob) => {
          try {
            if (!blob) { 
              alert('å¯¼å‡ºå¤±è´¥ï¼šç”Ÿæˆå›¾ç‰‡ä¸ºç©º'); 
              Logger.error('å¯¼å‡ºå¤±è´¥', { reason: 'ç”Ÿæˆå›¾ç‰‡ä¸ºç©º' });
              return; 
            }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `html-preview-100-${Date.now()}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 100);
            Logger.log('PNGä¿å­˜å®Œæˆ', { size: blob.size });
            console.log('âœ… å¯¼å‡ºæˆåŠŸ');
          } catch (blobErr) {
            console.error('âŒ Blobå¤„ç†å¤±è´¥:', blobErr);
            Logger.error('Blobå¤„ç†å¤±è´¥', { message: blobErr?.message });
            alert('å¯¼å‡ºå¤±è´¥ï¼š' + (blobErr?.message || 'æœªçŸ¥é”™è¯¯'));
          } finally {
            // æ¢å¤åŸå§‹å›¾ç‰‡ src
            try {
              Array.from(iframeDoc.images || []).forEach(img => {
                const orig = img.getAttribute('data-original-src');
                if (orig) {
                  img.setAttribute('src', orig);
                  img.removeAttribute('data-original-src');
                }
              });
              Logger.log('åŸå§‹å›¾ç‰‡å·²æ¢å¤');
            } catch {}
            
            autoExportBtn.textContent = 'âš¡ ä¸€é”®å¯¼å‡º(100%)';
            autoExportBtn.disabled = !htmlInput.value.trim();
            const s = Logger.check();
            Logger.log('å¯¼å‡ºç»“æŸ', s);
          }
        }, 'image/png');

      } catch (err) {
        console.error('ä¸€é”®å¯¼å‡ºå¤±è´¥:', err);
        Logger.error('ä¸€é”®å¯¼å‡ºå¤±è´¥', { message: err?.message, type: err?.constructor?.name });
        alert('å¯¼å‡ºå¤±è´¥ï¼š' + (err?.message || err?.type || 'æœªçŸ¥é”™è¯¯'));
        
        // æ¢å¤åŸå§‹å›¾ç‰‡ src
        try {
          const iframeDoc = preview.contentDocument || preview.contentWindow?.document;
          if (iframeDoc) {
            Array.from(iframeDoc.images || []).forEach(img => {
              const orig = img.getAttribute('data-original-src');
              if (orig) {
                img.setAttribute('src', orig);
                img.removeAttribute('data-original-src');
              }
            });
            Logger.log('åŸå§‹å›¾ç‰‡å·²æ¢å¤ï¼ˆå¼‚å¸¸è·¯å¾„ï¼‰');
          }
        } catch {}
        
        autoExportBtn.textContent = 'âš¡ ä¸€é”®å¯¼å‡º(100%)';
        autoExportBtn.disabled = !htmlInput.value.trim();
        const s = Logger.check();
        Logger.log('å¯¼å‡ºç»“æŸ', s);
      }
    }

    

    // å·²ç§»é™¤æˆªå›¾å¯¼å‡ºåŠŸèƒ½

    // ç›‘å¬è¾“å…¥äº‹ä»¶
    htmlInput.addEventListener('input', updatePreview);
    // ç›‘å¬æ˜¾ç¤ºæ¯”ä¾‹åˆ‡æ¢
    ratioSelect.addEventListener('change', (e) => {
      applyDisplayRatio(e.target.value);
      requestAnimationFrame(() => autoFixTopBlank());
    });
    if (logToggleBtn) logToggleBtn.addEventListener('click', () => { const show = Logger.toggle(); Logger.log('åˆ‡æ¢æ—¥å¿—é¢æ¿', { show }); });
    if (exportLogBtn) exportLogBtn.addEventListener('click', () => { Logger.export(); Logger.log('å¯¼å‡ºæ—¥å¿—'); });
    // å³ä¾§ç®€åŒ–åï¼Œæ— å®½åº¦/è¾¹è·è¾“å…¥
    window.addEventListener('resize', () => requestAnimationFrame(updateRatioScale));

    // é¢„è§ˆæ–‡æ¡£æ¯æ¬¡åŠ è½½åï¼Œå¤šæ¬¡å°è¯•ä¿®æ­£é¡¶éƒ¨ç©ºç™½å¹¶é‡ç®—æ¯”ä¾‹ï¼ˆåº”å¯¹å­—ä½“/å›¾ç‰‡å¼‚æ­¥åŠ è½½åçš„å¸ƒå±€å˜åŒ–ï¼‰
    preview.addEventListener('load', () => {
      const run = () => { autoFixTopBlank(); updateRatioScale(); };
      requestAnimationFrame(run);
      setTimeout(run, 120);
      setTimeout(run, 400);
      setTimeout(run, 800);
      setTimeout(run, 1200);
      Logger.log('é¢„è§ˆåŠ è½½å®Œæˆ');
    });

    // é¡µé¢åŠ è½½å®Œæˆ
    console.log('[App] åˆå§‹åŒ–å®Œæˆ');
    
    // åŠ è½½ç¤ºä¾‹ä»£ç 
    htmlInput.value = exampleHTML;
    updatePreview();
    applyDisplayRatio(ratioSelect.value);
    updateRatioScale();
    // å³ä¾§ç®€åŒ–åï¼Œç§»é™¤å®½åº¦/è¾¹è·åˆå§‹èµ‹å€¼
  </script>
</body>
</html>
